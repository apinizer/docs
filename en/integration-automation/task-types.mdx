---
title: 'Task Types'
description: 'Understanding Sequential, Parallel, and Decision task types in Task Flows, and when to use each type'
---

Task Flows support different task types to control execution flow. Understanding these task types is essential for designing efficient and reliable integration workflows.

## Overview

Task types determine how tasks are executed in a Task Flow. Apinizer supports three main task types: Sequential, Parallel, and Decision.

<CardGroup cols={2}>
  <Card title="Sequential Tasks" icon="arrow-right">
    Execute tasks one after another
  </Card>
  <Card title="Parallel Tasks" icon="layer-group">
    Execute multiple tasks simultaneously
  </Card>
  <Card title="Decision Tasks" icon="code-branch">
    Conditional task execution
  </Card>
</CardGroup>

## Sequential Tasks

Sequential tasks execute one after another in a linear sequence. Each task waits for the previous task to complete before starting.

### Characteristics

* **Order Matters**: Tasks execute in the order they are defined
* **Dependency**: Each task can use output from previous tasks
* **Error Propagation**: If one task fails, subsequent tasks may not execute
* **Simple Flow**: Easy to understand and debug

### Use Cases

**Data Pipeline:**

```
1. Fetch data from source (Database Connector)
2. Transform data (Script Connector)
3. Validate data (Script Connector)
4. Save to destination (Database Connector)
```

**API Chain:**

```
1. Authenticate (HTTP Connector)
2. Get user info (HTTP Connector)
3. Process user data (Script Connector)
4. Send notification (Email Connector)
```

### Example Configuration

**Sequential Flow:**

```
Start → Task 1 → Task 2 → Task 3 → End
```

**Execution Order:**

1. Task 1 executes
2. Task 2 executes after Task 1 completes
3. Task 3 executes after Task 2 completes

### Advantages

* Simple to design and understand
* Easy to debug (linear execution)
* Predictable execution order
* Natural for dependent operations

### Disadvantages

* Slower execution (tasks wait for each other)
* Not optimal for independent operations
* Sequential bottleneck

## Parallel Tasks

Parallel tasks execute simultaneously, allowing multiple operations to run at the same time. This improves performance when tasks are independent.

### Characteristics

* **Simultaneous Execution**: Multiple tasks run at the same time
* **Independence**: Tasks should not depend on each other
* **Synchronization**: All tasks complete before proceeding
* **Performance**: Faster overall execution

### Use Cases

**Independent Operations:**

```
Parallel Branch:
  ├─ Fetch user data (HTTP Connector)
  ├─ Fetch order data (HTTP Connector)
  ├─ Fetch product data (HTTP Connector)
  └─ All complete → Merge results
```

**Multiple Notifications:**

```
Parallel Branch:
  ├─ Send email notification (Email Connector)
  ├─ Send SMS notification (HTTP Connector)
  ├─ Log to database (Database Connector)
  └─ All complete → Continue
```

### Example Configuration

**Parallel Flow:**

```
Start → Parallel Node
         ├─ Task A
         ├─ Task B
         └─ Task C
      → Merge → End
```

**Execution:**

* Task A, B, and C start simultaneously
* All tasks execute concurrently
* Flow waits for all tasks to complete
* Execution continues after all tasks finish

### Advantages

* Faster execution for independent tasks
* Better resource utilization
* Improved throughput
* Suitable for I/O-bound operations

### Disadvantages

* More complex error handling
* Requires synchronization
* May consume more resources
* Harder to debug

### Best Practices

* Use parallel tasks for independent operations
* Ensure tasks don't have dependencies
* Handle errors in each parallel branch
* Consider resource limits
* Monitor parallel execution performance

## Decision Tasks

Decision tasks provide conditional execution based on conditions. They enable branching logic (IF-THEN-ELSE) in Task Flows.

### Characteristics

* **Conditional Logic**: Execute tasks based on conditions
* **Branching**: Multiple execution paths
* **Boolean Evaluation**: Conditions evaluate to true/false
* **Flexible Flow**: Dynamic execution paths

### Use Cases

**Conditional Processing:**

```
Decision: customer.status === 'premium'
  ├─ True → Apply premium discount (Script Connector)
  └─ False → Apply standard pricing (Script Connector)
```

**Error Handling:**

```
Decision: order.total > 1000
  ├─ True → Require approval (Email Connector)
  └─ False → Auto-approve (Database Connector)
```

**Data Validation:**

```
Decision: isValid(data)
  ├─ True → Process data (Database Connector)
  └─ False → Send error notification (Email Connector)
```

### Example Configuration

**Decision Flow:**

```
Start → Decision Node
         ├─ Condition: ${customer.balance} > 1000
         ├─ True Path → Task A
         └─ False Path → Task B
      → Merge → End
```

**Condition Syntax:**

```javascript
// Simple comparison
${variable} === 'value'
${number} > 100

// Complex conditions
${customer.status} === 'active' && ${customer.balance} > 0
${order.items.length} > 0 || ${order.total} > 100

// Function calls
isValid(${data})
contains(${array}, 'value')
```

### Condition Types

**Comparison Operators:**

* `===` Equal to
* `!==` Not equal to
* `>` Greater than
* `<` Less than
* `>=` Greater than or equal
* `<=` Less than or equal

**Logical Operators:**

* `&&` AND
* `||` OR
* `!` NOT

**String Operations:**

* `contains(string, substring)`
* `startsWith(string, prefix)`
* `endsWith(string, suffix)`
* `matches(string, regex)`

**Array Operations:**

* `contains(array, value)`
* `length(array) > 0`
* `isEmpty(array)`

### Advantages

* Flexible execution paths
* Dynamic flow control
* Conditional processing
* Error handling capabilities

### Disadvantages

* More complex flow design
* Requires careful condition design
* Multiple paths to test
* Potential for logic errors

## Combining Task Types

You can combine different task types to create complex workflows:

### Sequential with Parallel

```
Start → Task 1 → Parallel Node
                  ├─ Task A
                  ├─ Task B
                  └─ Task C
               → Task 2 → End
```

### Parallel with Decision

```
Start → Parallel Node
         ├─ Task A
         ├─ Task B
         └─ Task C
      → Decision Node
         ├─ True → Task D
         └─ False → Task E
      → End
```

### Nested Decisions

```
Start → Decision 1
         ├─ True → Decision 2
         │         ├─ True → Task A
         │         └─ False → Task B
         └─ False → Task C
      → End
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Choose Appropriate Type" icon="check-circle">
    Select task type based on dependencies and requirements
  </Card>
  <Card title="Minimize Parallel Complexity" icon="layer-group">
    Keep parallel branches simple and independent
  </Card>
  <Card title="Clear Conditions" icon="code-branch">
    Write clear, testable conditions for decision tasks
  </Card>
  <Card title="Error Handling" icon="shield-halved">
    Handle errors appropriately for each task type
  </Card>
  <Card title="Performance Consideration" icon="gauge">
    Use parallel tasks for independent operations to improve performance
  </Card>
  <Card title="Testing" icon="flask">
    Test all execution paths, especially decision branches
  </Card>
</CardGroup>

## Performance Considerations

### Sequential Tasks

* **Use When**: Tasks have dependencies
* **Performance**: Slower but predictable
* **Resource Usage**: Lower resource consumption
* **Best For**: Data pipelines, dependent operations

### Parallel Tasks

* **Use When**: Tasks are independent
* **Performance**: Faster execution
* **Resource Usage**: Higher resource consumption
* **Best For**: Independent API calls, parallel notifications

### Decision Tasks

* **Use When**: Conditional logic is needed
* **Performance**: Minimal overhead
* **Resource Usage**: Low
* **Best For**: Conditional processing, error handling

## Related Topics

<CardGroup cols={2}>
  <Card title="Task Flow Design" icon="diagram-project" href="/en/integration-automation/task-flow-design">
    Learn how to design Task Flows
  </Card>
  <Card title="Variables & Data Passing" icon="arrows-rotate" href="/en/integration-automation/variables-data-passing">
    Understand variable management
  </Card>
  <Card title="Performance Optimization" icon="gauge" href="/en/integration-automation/performance-optimization">
    Optimize Task Flow performance
  </Card>
  <Card title="Error Handling & Retries" icon="rotate-right" href="/en/integration-automation/error-handling-retries">
    Configure error handling strategies
  </Card>
</CardGroup>
