---
title: "JOSE Application Policy"
description: "You can generate, sign, and optionally encrypt JWT from request or response"
---

<Tip>
This document explains the detailed usage of a specific policy. If you are using Apinizer policies for the first time or want to learn the general working principles of policies, we recommend reading the [What is Policy?](/en/concepts/core-concepts/what-is-policy) page first.
</Tip>

## Overview

### What is its Purpose?

- Simplifies consumer integrations by repackaging API Proxy response or request as JWT in JOSE standards-compliant format.
- Secures claim data carried between application services with signature and encryption layers.
- Ensures centralized and auditable key management by working integrated with JWK vault.
- Dynamically triggered in specific endpoint, header, or environment combinations with condition engine support.
- Manages organization-specific token enrichments without code changes through additional claim map and data manipulation targets.

### Working Principle

1. **Request Arrival**: For each HTTP/HTTPS request arriving at the API Gateway, the source IP address of the request is identified.
2. **Policy Check**: If the JOSE Application policy is active, the system checks in the following order:
   - Is a Condition defined? If so, is the condition met?
   - Is the policy active (active=true)?
   - Is a Variable being used or is Apinizer default?
3. **Token Generation and Security Layer**: After target field is determined, claim set is collected, additional claim map is added, signing and optional encryption is applied according to JWK selection.
4. **Decision Making**:
   - **Match Found**: Generated JWT is written to specified target (body, Authorization header, or variable) and traffic continues.
   - **No Match**: Policy remains disabled, request is transmitted with original content.
5. **Error Handling**: Customizable HTTP status code and error message are returned for requests that do not comply with the policy rule.

## Features and Capabilities

### Basic Features

- **Flexible JOSE Target**: Token output can be set to body (BODY), Authorization header (AUTHORIZATION_HEADER), selected variable (CHOOSE_FROM_VARIABLE), or empty target (EMPTY); facilitates response manipulations.
- **JWT Claims Claim and Escape JSON String**: When target is not EMPTY, which claim name the raw data is written to in the payload (jwtClaimsClaim) and whether the JSON string is escaped (escapeJsonString) can be configured.
- **Ready Claim Keys**: Core claim fields such as Issuer, Subject, Audience, Expiration, Issue Time, JWT ID and Type (add type to header) are managed with key/lock combinations.
- **Additional Claim Map**: Text, list, or numeric claims can be added and edited from the interface with type-controlled MapValue support.
- **Active/Passive Status Control**: Easily change the active or passive status of the policy (active/passive toggle). In passive mode, the policy is not applied but its configuration is preserved.
- **Condition-Based Application**: Determine when the policy will be applied by creating complex conditions with Query Builder (e.g., only for specific endpoints or header values).

### Advanced Features

- **Key Source Mode**: Key for signature and encryption can be **Embedded** (JWK from Secret Manager) or **Dynamic HTTP** (remote key fetch via HTTP request).
- **Dynamic Key Fetching**: When Dynamic HTTP is selected, HTTP request (Test Console), Key Extraction Variable, Key Format (AUTO_DETECT, PUBLIC_KEY, PRIVATE_KEY, CERTIFICATE, JWK_JSON), Key Algorithm, Kid (optional), cache settings (Apply By variable, Capacity, TTL, Cache Storage Type, Respect Cache Invalidation Headers, Connection Timeout, Error Handling Type), Retry on Key Error, Invalidate Cache on Validation Error and **Try It (Parse Response)** button can be used for testing.
- **JWK Management Integration**: In Embedded mode, JWK search, selection, update and new key generation through Secret Manager is done with single click.
- **Dual-Layer Security**: Token integrity and confidentiality are simultaneously ensured by applying signature and encryption combination in the same request.
- **Data Manipulation Synchronization**: For generated JWT/JWE, Injection Target (encoded claims target) and variable assignment for decoded claims (decoded claims target variable) enable data sharing between chain policies.
- **Export/Import Feature**: Export policy configuration as a ZIP file. Import to different environments (Development, Test, Production). Version control and backup capability.
- **Policy Group and Proxy Group Support**: Manage multiple policies within Policy Group. Bulk policy assignment to Proxy Groups. Centralized update and deploy operations.
- **Deploy and Versioning**: Deploy policy changes to live environment. See which API Proxies use it (Policy Usage). Proxy Group and Policy Group usage reports.

## Usage Scenarios

| Scenario | Status | Solution (Policy Application) | Expected Behavior / Result |
|----------|--------|-------------------------------|---------------------------|
| Converting Microservice Response to JWT | Service returns plain text JSON, consumer expects JWT | `joseTarget=BODY`, ready claims active, signature open | Response returns in JWT format, consumer does not do additional work |
| Carrying JWT via Header | Mobile client wants signed token in Authorization header | `joseTarget=AUTHORIZATION_HEADER`, `addTypeToHeader=true`, `typeValue=JWT` | Token is added as `Authorization: JWT <token>` |
| Multiple Audience Management | Same API transmits token to different target systems | `addAudience=true`, multiple values added to audience list | Token contains multiple values in `aud` claim |
| Signing with Internal System Key | Token signed by issuer side is preferred | `sign=true`, `signByIssuer=true` is selected | Gateway does not require signature key, issuer signature is preserved |
| Dual-Layer Security | External integration requires signature+encryption combination | `sign=true`, `encrypt=true`, appropriate JWKs or Dynamic HTTP selected | Token is first signed then encrypted with selected method |
| Data Manipulation Chain | Next policy needs decoded claims | Set token write target with `encodedClaimsTargetForDataManipulation`, assign variable for decoded claims | Decoded claims are stored in the defined variable |
| Remote Key Signing/Encryption | Key will be fetched from an HTTP endpoint | Key Source Mode = DYNAMIC_HTTP, define HTTP Request and Key Extraction Variable, test with Try It | Key is fetched remotely at runtime and can be cached |

## Configuring Policy Parameters

In this step, users can **create a new policy** or **configure existing policy parameters** to define access rules. The defined parameters directly affect how the policy works (e.g., which target to write token to, conditional activations, signature/encryption source, etc.). This allows the policy to be customized according to organization-specific requirements while being centrally manageable.

### Creating a New JOSE Application Policy

<img src="/images/develop/politikalar/jose-imp1.png" alt="JOSE Application Policy" width="1000" />

<img src="/images/develop/politikalar/jose-imp2.png" alt="JOSE Application Policy" width="1000" />

### Configuration Steps

| Step | Description / Operation |
|------|----------------------|
| **Step 1: Go to Creation Page** | - Go to **Development → Global Settings → Global Policies → JOSE Application Policy** from the left menu.<br />- Click the **[+ Create]** button at the top right. |
| **Step 2: Enter Basic Information (Definition tab)** | **Policy Status:** Read-only; shows Active or Passive status. New policies are active by default. Can be changed via toggle.<br /><br />**Name (Required):** Example: `Production_JOSE`. Enter a unique name; must not start with space; max 255 characters. System checks automatically: green checkmark = available, red X = existing name.<br /><br />**Description:** Example: "Converts output body to signed JWT". Max 1000 characters; describes the purpose of the policy. |
| **Step 3: Policy Configuration** | **JOSE Target (Target for Signing/Encryption) — Required:** Select BODY, AUTHORIZATION_HEADER, CHOOSE_FROM_VARIABLE, or EMPTY.<br /><br />**JOSE Target Variable — Conditional:** Visible only when JOSE Target = CHOOSE_FROM_VARIABLE; required. Select project variable (Select Variable / Change / Remove buttons). Selected variable can be edited with **Update Variable**.<br /><br />**JWT Claims Claim (Claim name for raw data):** Visible only when JOSE Target ≠ EMPTY. Determines which claim name the raw data is written to in JWT payload; default `data`. Can be left empty to place entire body.<br /><br />**Escape JSON String (Use JSON string as string):** Visible only when JOSE Target ≠ EMPTY. Toggle; selects whether JSON string is used as string for the claim name. |
| **Step 4: Claim Settings (Claim Settings panel)** | **Add Issue Time:** Toggle; adds `iat` claim.<br /><br />**Add JWT ID:** Toggle; adds `jti` claim.<br /><br />**Add Type to Header:** Toggle; adds type information to header.<br /><br />**Type Value — Conditional, required:** Visible only when Add Type to Header is on; e.g. `JWT`.<br /><br />**Add Issuer:** Toggle.<br /><br />**Issuer — Conditional, required:** Visible only when Add Issuer is on.<br /><br />**Add Audience:** Toggle.<br /><br />**Audience List — Conditional, required:** Visible only when Add Audience is on. Add values as chips; remove by clicking from list. At least one value required.<br /><br />**Add Subject:** Toggle.<br /><br />**Subject — Conditional, required:** Visible only when Add Subject is on.<br /><br />**Add Expiration Time:** Toggle.<br /><br />**Expiration Time Value — Conditional, required:** Visible only when Add Expiration Time is on; number, min 0.<br /><br />**Expiration Time Unit — Conditional, required:** Visible only when Add Expiration Time is on; time unit (e.g. SECOND, MINUTE, HOUR).<br /><br />**Additional Claim Map:** Table: Key, Type (valueType), Value, action column. Add new claim with **+** button; Edit/Remove from row menu. In Add/Edit Claim dialog: Key, Value Type, Value are required. |
| **Step 5: Signature Configuration — JWS Application (Signature panel)** | **Sign:** Toggle; enables/disables token signature.<br /><br />**Sign by Issuer:** Toggle; signature is provided by issuer.<br /><br />The following fields are visible only when **Sign** is on and **Sign by Issuer** is off:<br /><br />**Key Source Mode — Required:** EMBEDDED or DYNAMIC_HTTP.<br /><br />**— If EMBEDDED:** **JWK for Digital Signing (jwkIdForValidationAndSign) — Required:** Dropdown (signature JWKs from Secret Manager), **Clear** and **New** buttons. Selected JWK is shown in table (Name, Description, Type, Algorithm); click row to edit/detail.<br /><br />**— If DYNAMIC_HTTP:** **HTTP Request Configuration (httpRequest):** Test Console; define service URL and request (method, header, body, etc.). Required; URL must be filled before save.<br />• **Key Extraction Variable — Required:** Variable from which key is extracted from HTTP response; assign via variable selector.<br />• **Key Format — Required:** AUTO_DETECT, PUBLIC_KEY, PRIVATE_KEY, CERTIFICATE, JWK_JSON.<br />• **Key Algorithm — Required:** Algorithm list (e.g. NONE, RS256, ES256 …).<br />• **Kid (Optional):** Text; placeholder "Optional - for JWK Set selection".<br />• **Enable Cache:** Toggle; when on, cache fields below are visible and required when cache is on: **Apply By**, **Capacity**, **TTL**, **Cache Storage Type**, **Respect Cache Invalidation Headers**, **Cache Connection Timeout**, **Cache Error Handling Type**.<br />• **Retry on Key Error**, **Invalidate Cache on Validation Error** (visible when cache is on).<br />• **Parse Response (Try It):** Button; tests configuration; on success, detected Key Format/Algorithm can be auto-assigned. |
| **Step 6: Encryption Configuration — JWE Application (Encrypt panel)** | **Encrypt:** Toggle.<br /><br />**Encryption Method — Conditional, required:** Visible only when Encrypt is on; select from encryption method list.<br /><br />**Encrypt by Issuer:** Toggle; encryption is done by issuer.<br /><br />The following fields are visible only when **Encrypt** is on and **Encrypt by Issuer** is off:<br /><br />**Key Source Mode — Required:** EMBEDDED or DYNAMIC_HTTP.<br /><br />**— If EMBEDDED:** **JWK for Encryption (jwkIdForDecryptionAndEncryption) — Required:** Dropdown (encryption JWKs from Secret Manager), Clear and New buttons. Selected JWK is shown in table.<br /><br />**— If DYNAMIC_HTTP:** **HTTP Request Configuration:** Test Console; URL and request — required.<br />• **Key Extraction Variable — Required.**<br />• **Key Format — Required.**<br />• **Key Algorithm — Required.**<br />• **Kid — Optional.**<br />• **Enable Cache:** Toggle; when on: Apply By, Capacity, TTL, Cache Storage Type, Respect Cache Invalidation Headers, Cache Connection Timeout, Cache Error Handling Type (all required when cache is on).<br />• **Retry on Key Error:** Toggle.<br />• **Invalidate Cache on Validation Error:** Toggle (visible when cache is on).<br />• **Parse Response (Try It):** Button. |
| **Step 7: Data Manipulation (Data Manipulation panel)** | **Encoded Claims Target for Data Manipulation (Injection Target for generated JWT/JWE) — Required:** Target where token will be written: BODY, AUTHORIZATION_HEADER, or CHOOSE_FROM_VARIABLE.<br /><br />**Decoded Claims Target Variable — Conditional, required:** Visible only when Injection Target = CHOOSE_FROM_VARIABLE. Project variable where decoded claims will be written; assign with Select Variable / Change / Remove and Update buttons. |
| **Step 8: Define Condition (Condition tab) — Optional** | Go to **Condition** tab. Define condition rules with Query Builder; determines when the policy is active.<br /><br />Examples: Environment-based `Header = X-Environment, Equals, production`; API Key `Header = X-API-Key, Starts With = PROD-`; Endpoint `Path = /api/admin/*`. If no condition is defined, policy is always applied. |
| **Step 9: Error Message Customization (Error Message Customization tab) — Optional** | Go to **Error Message Customization** tab. Customize HTTP status code and message to return when access is denied.<br /><br />Default: `{ "statusCode": 403, "message": "[Default error message]" }`. Custom: `{ "statusCode": 403, "errorCode": "[CUSTOM_ERROR_CODE]", "message": "[Custom message]" }`. |
| **Step 10: Save** | Click the **[Save]** button at the top right.<br /><br />**Checklist:** Unique name; JOSE Target and (if CHOOSE_FROM_VARIABLE) JOSE Target Variable; if Add Type to Header then Type Value; if Add Issuer then Issuer; if Add Audience then at least one Audience; if Add Subject then Subject; if Add Expiration Time then Expiration Time Value + Unit; if Sign is on and Sign by Issuer is off then per Key Source Mode EMBEDDED with JWK selected or DYNAMIC_HTTP with URL + Key Extraction Variable + Key Format (+ if cache on: Apply By, Capacity, TTL etc.); if Encrypt is on then Encryption Method and (if Encrypt by Issuer off) same JWK/Dynamic HTTP rules; Encoded Claims Target; if CHOOSE_FROM_VARIABLE then Decoded Claims Target Variable.<br /><br />**Result:** Policy is added to list; can be connected to APIs; if global policy, automatically applied. |

**Tabs (besides Definition):** Definition, Condition, Error Message Customization; in page mode **API Proxies Using Policy** and **API Proxy Groups Using Policy** tabs are also visible.

For descriptions of **Conditions** and **Error Message Customization** panels, you can review the [Conditions](/en/concepts/core-concepts/what-is-policy#conditions) and [Error Message Customization](/en/concepts/core-concepts/what-is-policy#error-message-customization-error-message-customization) sections on the [What is Policy?](/en/concepts/core-concepts/what-is-policy) page.

## Deleting the Policy

For deletion steps of this policy and operations to be applied when in use, you can refer to the [Remove Policy from Flow](/en/develop/api-proxy-configuration/policy-management#remove-policy-from-flow) section on the [Policy Management](/en/develop/api-proxy-configuration/policy-management) page.

## Exporting/Importing the Policy

For export (Export) and import (Import) steps of this policy, you can refer to the [Export/Import](/en/admin/secrets-management/export-import) page.

## Connecting the Policy to API

For the process of how this policy will be connected to APIs, you can refer to the [Connect Policy to API](/en/develop/api-proxy-configuration/policy-management#adding-policy-to-flow) section on the [Policy Management](/en/develop/api-proxy-configuration/policy-management) page.

## Advanced Features

| Feature | Description and Steps |
|---------|---------------------|
| **Dynamic Claim Mapping** | - Press **+** from `Additional Claim Map` table.<br />- Select claim key and appropriate `valueType`.<br />- Fill value and save; change is immediately reflected in list. |
| **Embedded JWK Signing/Encryption** | - In signature or encryption panel, when Key Source Mode = EMBEDDED, open the relevant JWK selector.<br />- Select existing key or go to Secret Manager with **New**.<br />- Policy form is automatically updated when current JWK is saved. |
| **Dynamic HTTP Key Fetching** | - Select Key Source Mode = DYNAMIC_HTTP.<br />- Define service URL and request in HTTP Request field with Test Console.<br />- Configure Key Extraction Variable (required), Key Format, Key Algorithm; if enabling cache fill Apply By variable, Capacity, TTL and other cache fields.<br />- Test with **Parse Response (Try It)**; on success, detected format/algorithm can be auto-assigned. |
| **Token Chain Manipulation** | - From **Injection Target for generated JWT/JWE**, select target where token will be written (BODY, AUTHORIZATION_HEADER, or CHOOSE_FROM_VARIABLE).<br />- If CHOOSE_FROM_VARIABLE, define **Target variable for decoded claims** to pass decoded data to another policy.<br />- Complete data flow by using the same variable as source in the relevant second policy. |

## Best Practices

### Things to Do and Best Practices

| Category | Description / Recommendations |
|----------|----------------------------|
| **Claim Design** | **Bad:** Adding all unnecessary fields as claims.<br />**Good:** Defining only functional claims.<br />**Best:** Maintaining minimal but sufficient set with regular claim audits. |
| **JWK and Dynamic Key Management** | **Bad:** Continuing to use expired keys or incorrect Dynamic HTTP URL.<br />**Good:** Performing Embedded JWK rotation at intervals; for Dynamic HTTP, test with Try It and use cache.<br />**Best:** Reliable key supply via automatic rotation through Secret Manager (Embedded) or cache + retry/invalidate settings (Dynamic HTTP). |
| **Signature and Encryption Combination** | **Bad:** Unnecessarily adding both signature and encryption to same token.<br />**Good:** Being satisfied with only one according to security requirements.<br />**Best:** Ensuring full security by applying signature first then encryption on sensitive data. |
| **Data Manipulation** | **Bad:** Writing decoded data to variables with empty names.<br />**Good:** Using meaningful variable names.<br />**Best:** Documenting data flow between policies and determining standard names. |
| **Error Message Strategy** | **Bad:** Leaving default error message in all environments.<br />**Good:** Preparing environment-based custom messages.<br />**Best:** Including reference codes in error messages for traceability. |

### Security Best Practices

| Security Area | Description / Warnings |
|---------------|----------------------|
| **Key Storage** | Keep JWKs only within Secret Manager in Embedded mode; for Dynamic HTTP, endpoint security and cache access restrictions are important. |
| **Token Lifetime** | Keep Expiration values short, establish Sliding or Refresh token mechanisms. |
| **Issuer and Audience Accuracy** | Determine `issuer` and `audienceList` values according to corporate naming standard and update in revisions. |
| **Additional Claim Hygiene** | Make encryption mandatory if personal data exists in additional claims and apply data minimization. |
| **Signature Key Authorities** | Limit JWK editing authority to ROLE_API_SECURITY, track audit logs. |

### Things to Avoid

| Category | Description / Warnings |
|----------|----------------------|
| **Inconsistent Claim Structure** | **Why to avoid:** Claims outside schema cause parse errors on consumer side.<br />**Alternative:** Deploy claim changes in version-controlled manner. |
| **Wrong JWK or Dynamic Key Mapping** | **Why to avoid:** Selecting missing or different-algorithm JWK/format breaks token verification.<br />**Alternative:** Use filtered JWK list for the algorithm (Embedded) or correct Key Format/Algorithm and Try It (Dynamic HTTP). |
| **Infinite Token Duration** | **Why to avoid:** Token revocation is not possible in case of security breach.<br />**Alternative:** Design short-term tokens and revocation list. |
| **Target Field Incompatibility** | **Why to avoid:** Token written to header instead of response body may not be consumed.<br />**Alternative:** Clarify target field according to integration documentation. |

### Performance Tips

| Criterion | Recommendation / Impact |
|----------|----------------------|
| **Token Size** | Remove unnecessary claims and keep JSON in minimal format. Transmission time and bandwidth decrease. |
| **Encryption Method** | Prefer algorithms with hardware support (e.g. A256GCM). CPU usage decreases, latency drops. |
| **Additional Claim Count** | Define only necessary claims in MapValue table. Token size decreases, verification time shortens. |
| **Condition Engine** | Avoid unnecessary nested conditions in Query Builder. Policy evaluation process speeds up. |
| **Embedded JWK Lookup** | Activate Secret Manager options that cache frequently used JWKs. I/O delays decrease during signing/encryption. |
| **Dynamic HTTP Cache** | Keep Enable Cache on with appropriate Capacity and TTL so remote key is not fetched repeatedly. Latency and external service load decrease. |

## Frequently Asked Questions (FAQ)

| Category | Question | Answer |
|----------|----------|--------|
| **General** | When is JOSE Application Policy used? | Used in integrations requiring token generation, claim management, and secure transmission; especially effective in scenarios where consumer expects JWT. |
| **General** | Is it mandatory to open both signature and encryption simultaneously? | No, only signature or only encryption can be used according to requirements; both together are recommended for sensitive data. |
| **Technical** | How is JWK selection done? | When Key Source Mode = EMBEDDED, Secret Manager JWK list is opened; key matching appropriate algorithm and purpose is selected or new key is created. |
| **Technical** | How is key used with Dynamic HTTP? | Select Key Source Mode = DYNAMIC_HTTP; configure HTTP Request (Test Console) with URL and request, Key Extraction Variable (required), Key Format and Key Algorithm. Optional cache and Try It (Parse Response) for testing. |
| **Technical** | What happens when variable is selected as target? | When JOSE Target = CHOOSE_FROM_VARIABLE, the policy writes the token to the specified project variable; other policies or backend can read this variable. |
| **Usage** | How are values added to audience list? | Activate `Add Audience`, type value in the input box and confirm; each value is listed as a chip. |
| **Usage** | When is Type Value required? | When `Add Type to Header` is on, the type value to add to header (e.g. `JWT`) is required. |
| **Usage** | Do I have to customize error message? | Not mandatory; however, customization can be done in Error Message tab if directive information is needed for consumer side. |

