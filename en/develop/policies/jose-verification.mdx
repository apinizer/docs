---
title: "JOSE Verification"
description: "You can verify JOSE/JWT contents according to signature, encryption, and claim rules"
---

<Tip>
This document explains the detailed usage of a specific policy. If you are using Apinizer policies for the first time or want to learn the general working principles of policies, we recommend reading the [What is Policy?](/en/concepts/core-concepts/what-is-policy) page first.
</Tip>

## Overview

### What is its Purpose?

- Designed to ensure reliability of identity information by verifying JOSE/JWT tokens entering the API Proxy flow.
- Prevents unauthorized access and protects sensitive endpoints by enforcing specified issuer, audience, and claim rules.
- Provides clean data transfer to downstream services by securely decrypting encrypted JWE contents.
- Works integrated with centralized authorization policies in downstream services by broadcasting identity and role information at header level.

### Working Principle

1. **Request Arrival**: For each HTTP/HTTPS request arriving at the API Gateway, the source IP address of the request is identified.
2. **Policy Check**: If the JOSE Verification policy is active, the system checks in the following order:
   - Is a Condition defined? If so, is the condition met?
   - Is the policy active (active=true)?
   - Is a Variable being used or is Apinizer default?
3. **JOSE Content Resolution**: Token is read from specified source (body, Authorization header, or variable); if needed, decryption is performed with selected JWK and claim set is prepared for verification.
4. **Decision Making**:
   - **Match Found**: If signature/encryption is valid, claim and audience rules are met, and issuer ACL is approved, request continues in flow, user information is added to header if needed.
   - **No Match**: If token cannot be resolved, signature cannot be verified, claim rules are violated, or ACL rejection occurs, request is terminated by policy.
5. **Error Handling**: Customizable HTTP status code and error message are returned for requests that do not comply with the policy rule.

## Features and Capabilities

### Basic Features

- **Flexible JOSE Target**: Token can be read from body (BODY), Authorization header (AUTHORIZATION_HEADER), or selected variable (CHOOSE_FROM_VARIABLE); in variable scenarios it is assigned with variable selector.
- **Client Source**: Source where issuer/client information is read: HEADER, CLAIMS, or VARIABLE. If VARIABLE, Client Source Variable is required; otherwise Client Fieldname (JSON Path or claim name, e.g. `iss`) is required.
- **Granular Claim Verification**: Accepted audience list, Exact Match Claim (key-type-value), Required Claim and Prohibited Claim lists enable multi-layer verification.
- **Identity and Role Broadcasting**: User identity extracted from request can be added to header via Add User to Header (User Header Name required); supports centralized authorization control.
- **Active/Passive Status Control**: Easily change the active or passive status of the policy (active/passive toggle). In passive mode, the policy is not applied but its configuration is preserved.
- **Condition-Based Application**: Determine when the policy will be applied by creating complex conditions with Query Builder (e.g., only for specific endpoints or header values).

### Advanced Features

- **Key Source Mode**: Key for signature verification and decryption can be **Embedded** (JWK from Secret Manager) or **Dynamic HTTP** (remote key fetch via HTTP request).
- **Dynamic Key Fetching**: When Dynamic HTTP is selected, HTTP Request Configuration (Test Console), Key Extraction Variable, Key Format, Key Algorithm, Kid, cache settings (Apply By, Capacity, TTL, Cache Storage Type, Respect Cache Invalidation Headers, Connection Timeout, Cache Error Handling Type), Retry on Key Error, Invalidate Cache on Validation Error and **Parse Response (Try It)** button can be used for testing.
- **JWK Lifecycle Management**: In Embedded mode, signature and encryption keys are selected via Secret Manager or new key is created; necessary roles can define new keys.
- **Issuer ACL and IP Control**: Validate ACL for Issuer for issuer-based allow list; Check Client IP Address for client IP verification of the request maker (visible when policy list type is Request and validateACLforIssuer is on).
- **Claim Decode and Rewrite**: Strip and Decode (NONE, ALL, PARTIAL) isolates and decodes JWT/JWE payload; if PARTIAL, JWT Claims to Decode (jwtClaimsToDecode) is required. Decoded Claims Target (BODY, AUTHORIZATION_HEADER, CHOOSE_FROM_VARIABLE) and optionally Decoded Claims Target Variable direct the output.
- **Authorization Configuration**: When policy list type is Request, policy is not global and Validate ACL for Issuer is on, **Authorization Configuration** component is visible; role-based access and method access are configured.
- **Export/Import Feature**: Export policy configuration as a ZIP file. Import to different environments (Development, Test, Production). Version control and backup capability.
- **Policy Group and Proxy Group Support**: Manage multiple policies within Policy Group. Bulk policy assignment to Proxy Groups. Centralized update and deploy operations.
- **Deploy and Versioning**: Deploy policy changes to live environment. See which API Proxies use it (Policy Usage). Proxy Group and Policy Group usage reports.

## Usage Scenarios

| Scenario | Status | Solution (Policy Application) | Expected Behavior / Result |
|----------|--------|-------------------------------|---------------------------|
| Mobile JWT Verification | Mobile app carries JWT in Authorization header | `joseTarget=AUTHORIZATION_HEADER`, `validateSign=true`, use issuer JWKS or Embedded JWK | Valid token is accepted, invalid signatures return 401 |
| IoT JWE Resolution | IoT devices send encrypted payload | `decrypt=true`, `decryptByIssuer=false`, Key Source Mode with Embedded or Dynamic HTTP, select encryption JWK | Payload is decrypted, content is transferred to downstream services |
| Issuer Whitelisting | Access is not desired except for specific issuer values | `clientSourcePart=CLAIMS`, `clientFieldname=iss`, exact match map with list | Requests with incompatible issuer are blocked with 403 |
| Audience Segmentation | Microservices expect different audience | Fill `acceptedAudienceList` environment-based | Requests containing wrong audience receive customized error |
| User Header Injection | Downstream services require identity header | `addUserToHeader=true`, `userHeaderName=X-Authenticated-UserId` | Identity information is securely transmitted in header |
| Authorization Integration | Role-based access control is required | `enableAuthorization=true`, configure method access in Authorization Configuration component | Request is stopped by policy if role match is not provided |
| Remote Key Verification/Decryption | Key will be fetched from an HTTP endpoint | Key Source Mode = DYNAMIC_HTTP, define HTTP Request and Key Extraction Variable, test with Try It | Key is fetched remotely at runtime and can be cached |
| Policy Group Synchronization (optional) | Same rules will be used in multiple API Proxies | Create global policy, add to Policy Group | Policy is updated in all API Proxies with single change |

## Configuring Policy Parameters

In this step, users can **create a new policy** or **configure existing policy parameters** to define access rules. The defined parameters directly affect how the policy works (which source to read token from, claim/audience rules, signature/decryption source, ACL and authorization, etc.). This allows the policy to be customized according to organization-specific requirements while being centrally manageable.

### Creating a New JOSE Verification Policy

<img src="/images/develop/politikalar/jose-valid1.png" alt="JOSE Verification Policy" width="1000" />

<img src="/images/develop/politikalar/jose-valid2.png" alt="JOSE Verification Policy" width="1000" />

### Configuration Steps

| Step | Description / Operation |
|------|----------------------|
| **Step 1: Go to Creation Page** | - Go to **Development → Global Settings → Global Policies → JOSE Verification Policy** from the left menu.<br />- Click the **[+ Create]** button at the top right. |
| **Step 2: Enter Basic Information (Definition tab)** | **Policy Status:** Shows Active or Passive status. New policies are active by default. Can be changed via toggle.<br /><br />**Name (Required):** Example: `Production_JOSEValidation`. Enter a unique name; must not start with space; max 255 characters. System checks automatically: green checkmark = available, red X = existing name.<br /><br />**Description:** Example: "Performs JWT signature and encryption verification." Max 1000 characters; describes the purpose of the policy. |
| **Step 3: Policy Configuration — JOSE Source and Client Information** | **JOSE Target (Target for Verification/Decryption) — Required:** Select BODY, AUTHORIZATION_HEADER, or CHOOSE_FROM_VARIABLE.<br /><br />**JOSE Target Variable — Conditional, required:** Visible only when JOSE Target = CHOOSE_FROM_VARIABLE. Select project variable (Select Variable / Change / Remove and Update buttons).<br /><br />**Client Source Part (Define Client Source) — Required:** HEADER, CLAIMS, or VARIABLE. Determines where issuer/client information is read from.<br /><br />**Client Source Variable — Conditional, required:** Visible only when Client Source Part = VARIABLE. Select project variable.<br /><br />**Client Fieldname (JSON Path or Claim Name for Client Identification) — Conditional, required:** Visible only when Client Source Part ≠ VARIABLE. E.g. `iss`; required. |
| **Step 4: Claim Verification Settings (Claim panel)** | **Accepted Audience List:** Add values as chips by typing in the text box and confirming; remove by clicking from list. Optional.<br /><br />**Exact Match Claim Map:** Table: Key, Type (valueType), Value, action column. Add new claim with **+** button; Edit/Remove from row menu. In Add/Edit Claim dialog: Key, Value Type, Value are required.<br /><br />**Required Claim List:** Add claim names as chips; remove by clicking from list. Optional.<br /><br />**Prohibited Claim List:** Add prohibited claim names as chips in the same way. Optional. |
| **Step 5: JWE Decryption Settings (Decrypt panel)** | **Decrypt:** Toggle; enables/disables JWE decryption.<br /><br />**Decrypt by Issuer:** Toggle; visible only when Decrypt is on; decryption uses issuer-side key.<br /><br />The following fields are visible only when **Decrypt** is on and **Decrypt by Issuer** is off:<br /><br />**Key Source Mode — Required:** EMBEDDED or DYNAMIC_HTTP.<br /><br />**— If EMBEDDED:** **JWK for Decryption (jwkIdForDecryptionAndEncryption) — Required:** Dropdown (encryption JWKs from Secret Manager), Clear and New buttons. Selected JWK is shown in table.<br /><br />**— If DYNAMIC_HTTP:** **HTTP Request Configuration:** Test Console; URL and request — required.<br />• **Key Extraction Variable — Required.**<br />• **Key Format, Key Algorithm — Required.** Kid — Optional.<br />• **Enable Cache:** Toggle; when on: Apply By, Capacity, TTL, Cache Storage Type, Respect Cache Invalidation Headers, Cache Connection Timeout, Cache Error Handling Type (all required when cache is on).<br />• **Retry on Key Error, Invalidate Cache on Validation Error** (visible when cache is on).<br />• **Parse Response (Try It):** Button. |
| **Step 6: JWS Validation Settings (Validation panel)** | **Validate Expiration Time:** Toggle; token expiration is validated.<br /><br />**Validate Sign:** Toggle.<br /><br />**Validate by Issuer:** Toggle; visible only when Validate Sign is on; issuer JWKS is used.<br /><br />The following fields are visible only when **Validate Sign** is on and **Validate by Issuer** is off:<br /><br />**Key Source Mode — Required:** EMBEDDED or DYNAMIC_HTTP.<br /><br />**— EMBEDDED:** JWK for Validation (jwkIdForValidationAndSign) — required; list, Clear, New, JWK table.<br /><br />**— DYNAMIC_HTTP:** HTTP Request Configuration, Key Extraction Variable, Key Format, Key Algorithm, Kid, Enable Cache (Apply By, Capacity, TTL, Cache Storage Type, Respect Cache Invalidation Headers, Connection Timeout, Cache Error Handling Type), Retry on Key Error, Invalidate Cache on Validation Error, Parse Response (Try It). |
| **Step 7: ACL Settings (Authentication panel)** | **Add User to Header:** Toggle; user identity is added to header after verification.<br /><br />**User Header Name — Conditional, required:** Visible only when Add User to Header is on; e.g. `X-Authenticated-UserId`.<br /><br />**Validate ACL for Issuer:** Toggle; issuer-based ACL rules are applied.<br /><br />**Check Client IP Address — Conditional:** Visible only when policy list type is Request and Validate ACL for Issuer is on. Toggle; client IP verification is performed. |
| **Step 8: Data Manipulation (Data Manipulation panel)** | **Strip and Decode (Isolate and Decode JWT/JWE Payload):** NONE, ALL, or PARTIAL. NONE means no decode/targeting; with ALL or PARTIAL the following fields are used.<br /><br />**JWT Claims to Decode — Conditional, required:** Visible only when Strip and Decode = PARTIAL. Claim name to decode (e.g. `data`).<br /><br />**Decoded Claims Target — Conditional, required:** Visible only when Strip and Decode ≠ NONE. BODY, AUTHORIZATION_HEADER, or CHOOSE_FROM_VARIABLE.<br /><br />**Decoded Claims Target Variable — Conditional, required:** Visible only when Strip and Decode ≠ NONE and Target = CHOOSE_FROM_VARIABLE. Project variable where decoded claims will be written. |
| **Step 9: Authorization Configuration — Conditional** | **Authorization Configuration** component is visible only when **policy list type is Request**, policy is **not global**, and **Validate ACL for Issuer** is on. Role-based access, method access and authorization service settings are configured in this component. |
| **Step 10: Define Condition (Condition tab) — Optional** | Go to **Condition** tab. Define condition rules with Query Builder. Examples: Environment-based `Header = X-Environment, Equals, production`; API Key `Header = X-API-Key, Starts With = PROD-`; Endpoint `Path = /api/admin/*`. If no condition is defined, policy is always applied. |
| **Step 11: Error Message Customization (Error Message Customization tab) — Optional** | Go to **Error Message Customization** tab. Customize HTTP status code and message to return when access is denied. Default: `{ "statusCode": 403, "message": "[Default error message]" }`. Custom: `{ "statusCode": 403, "errorCode": "[CUSTOM_ERROR_CODE]", "message": "[Custom message]" }`. |
| **Step 12: Save** | Click the **[Save]** button at the top right.<br /><br />**Checklist:** Unique name; JOSE Target and (if CHOOSE_FROM_VARIABLE) JOSE Target Variable; Client Source Part; (if VARIABLE) Client Source Variable, (otherwise) Client Fieldname; if Add User to Header then User Header Name; if Strip and Decode ≠ NONE then Decoded Claims Target and (if CHOOSE_FROM_VARIABLE) Decoded Claims Target Variable; if Validate Sign is on and Validate by Issuer is off then per Key Source Mode JWK or Dynamic HTTP (URL, Key Extraction Variable, Key Format); if Decrypt is on and Decrypt by Issuer is off then same JWK/Dynamic HTTP rules.<br /><br />**Result:** Policy is added to list; can be connected to APIs; if global policy, automatically applied. |

**Tabs:** Definition, Condition, Error Message Customization; in page mode **API Proxies Using Policy** and **API Proxy Groups Using Policy** tabs are also visible.

For descriptions of **Conditions** and **Error Message Customization** panels, you can review the [Conditions](/en/concepts/core-concepts/what-is-policy#conditions) and [Error Message Customization](/en/concepts/core-concepts/what-is-policy#error-message-customization-error-message-customization) sections on the [What is Policy?](/en/concepts/core-concepts/what-is-policy) page.

## Deleting the Policy

For deletion steps of this policy and operations to be applied when in use, you can refer to the [Remove Policy from Flow](/en/develop/api-proxy-configuration/policy-management#remove-policy-from-flow) section on the [Policy Management](/en/develop/api-proxy-configuration/policy-management) page.

## Exporting/Importing the Policy

For export (Export) and import (Import) steps of this policy, you can refer to the [Export/Import](/en/admin/secrets-management/export-import) page.

## Connecting the Policy to API

For the process of how this policy will be connected to APIs, you can refer to the [Connect Policy to API](/en/develop/api-proxy-configuration/policy-management#adding-policy-to-flow) section on the [Policy Management](/en/develop/api-proxy-configuration/policy-management) page.

## Advanced Features

| Feature | Description and Steps |
|---------|---------------------|
| **Dynamic JWK Integration (Embedded)** | When Key Source Mode = EMBEDDED in signature or encryption panel, open the relevant JWK selector. Select existing key or go to Secret Manager with **New**. Saved JWK changes are automatically matched with the policy. |
| **Dynamic HTTP Key Fetching** | Select Key Source Mode = DYNAMIC_HTTP. Configure HTTP Request (Test Console) with URL and request, Key Extraction Variable (required), Key Format, Key Algorithm; if enabling cache fill Apply By, Capacity, TTL and other cache fields. Test with **Parse Response (Try It)**; if successful, detected format/algorithm can be auto-assigned. |
| **Issuer ACL and IP Verification** | Enable Validate ACL for Issuer. Update issuer-based ACL rules through security service. When policy list type is Request and validateACLforIssuer is on, verify incoming request IP with Check Client IP Address. |
| **Claim Decode & Rewrite** | Set Strip and Decode to **ALL** or **PARTIAL**. If PARTIAL, enter JWT Claims to Decode (jwtClaimsToDecode). Direct output with Decoded Claims Target to BODY, header, or variable; if CHOOSE_FROM_VARIABLE assign Decoded Claims Target Variable. Use the same variable in other policies. |
| **Authorization Configuration** | When policy is Request type, not global and Validate ACL for Issuer is on, configure enableAuthorization, addRolesToHeader, rolesHeaderName and method access in the visible Authorization Configuration component. |

## Best Practices

### Things to Do and Best Practices

| Category | Description / Recommendations |
|----------|----------------------------|
| **Audience Management** | **Bad:** Leaving Accepted audience empty.<br />**Good:** Defining separate audience value for each microservice.<br />**Best:** Managing environment-based audience lists (Development/Test/Production) with separate policies. |
| **Signature Verification** | **Bad:** Running with `validateSign` closed.<br />**Good:** Using issuer JWKS endpoint with `validateByIssuer` or selecting Embedded JWK.<br />**Best:** Enforcing centralized JWK vault or Dynamic HTTP cache in scenarios without issuer. |
| **Encryption Management** | **Bad:** Leaving `decrypt` closed in encrypted tokens.<br />**Good:** Enabling Decrypt by Issuer or Embedded JWK for decryption.<br />**Best:** Defining separate encryption key per issuer and periodic key rotation; use Try It and cache for Dynamic HTTP. |
| **Claim Policies** | **Bad:** Leaving claim lists undefined.<br />**Good:** Determining required and prohibited claim lists.<br />**Best:** Performing value-type verification with exact match map. |
| **Header Integration** | **Bad:** Not transmitting user identity to downstream services.<br />**Good:** Adding identity header with `addUserToHeader`.<br />**Best:** Matching role headers with security logs and auditing. |

### Security Best Practices

| Security Area | Description / Warnings |
|---------------|----------------------|
| **Key Management** | Store JWKs in Secret Manager in Embedded mode; for Dynamic HTTP, endpoint security and cache access restrictions are important. |
| **Issuer Trust** | Regularly update issuer whitelist; immediately remove suspicious issuers. |
| **Token Lifetime** | `validateExpirationTime` should always be open; restrict long-term tokens. |
| **Header Hardening** | Transmit added identity/role headers only over HTTPS; ensure masking in logs. |
| **Error Messages** | Do not share internal details in error messages; use generic message + error code combination. |

### Things to Avoid

| Category | Description / Warnings |
|----------|----------------------|
| **Static Embedded JWK** | **Why to avoid:** Keys embedded in code are vulnerable to leakage.<br />**Alternative:** Use Secret Manager (Embedded) or Dynamic HTTP for secure key supply. |
| **Ambiguous Claim Rules** | **Why to avoid:** Accepting all claims creates security vulnerability.<br />**Alternative:** Define required and prohibited lists. |
| **Undecoded Encrypted Data** | **Why to avoid:** Encrypted data passes without verification.<br />**Alternative:** Keep `decrypt` mandatory and bind appropriate JWK or Dynamic HTTP. |
| **Unmonitored Header Additions** | **Why to avoid:** Unaudited headers can be abused.<br />**Alternative:** Log header usage and apply access control. |

### Performance Tips

| Criterion | Recommendation / Impact |
|----------|----------------------|
| **JWK Cache** | Share frequently used JWKs via Secret Manager cache (Embedded) or Dynamic HTTP Enable Cache. Signature verification time decreases. |
| **Claim Rule Count** | Remove unnecessary claim checks. Policy execution time shortens. |
| **Decode Options** | Decode only needed claims (PARTIAL + jwtClaimsToDecode). Memory and CPU consumption decrease. |
| **Global vs Local Usage** | Prefer global policy for APIs sharing same rules. Management and deploy times shorten. |
| **Condition Simplification** | Remove unnecessary conditions in Query Builder. Condition evaluation time per request decreases. |
| **Dynamic HTTP Cache** | Keep Enable Cache on with appropriate Capacity and TTL. Remote key is not fetched repeatedly; latency decreases. |

## Frequently Asked Questions (FAQ)

| Category | Question | Answer |
|----------|----------|--------|
| **General** | What token types does the policy verify? | Supports JOSE standards (JWS/JWE); performs verification according to JSON Web Signature/Encryption rules. |
| **General** | Can the policy be shared for multiple API Proxies? | Yes, if defined globally, it is shared with multiple API Proxies through Policy Group. |
| **Technical** | How is it configured if issuer provides its own JWKS endpoint? | Enable **Validate by Issuer** so the gateway fetches keys from issuer JWKS. |
| **Technical** | How is encrypted JWE content resolved? | Enable **Decrypt**; if **Decrypt by Issuer** is off, configure Key Source Mode with Embedded (select JWK) or Dynamic HTTP (URL, Key Extraction Variable, Key Format, Key Algorithm and optional cache). Decrypted payload is written to the specified target. |
| **Technical** | How is key used with Dynamic HTTP? | Select Key Source Mode = DYNAMIC_HTTP; configure HTTP Request (Test Console), Key Extraction Variable (required), Key Format, Key Algorithm. Test with **Parse Response (Try It)**. |
| **Usage** | Is it safe to add user identity to header? | Transmit over HTTPS, mask header name (User Header Name), and allow only authorized services to read it. |
| **Usage** | How can I separate claim rules by environment? | Create separate policy copy per environment or define condition by environment header in **Condition** tab. |
| **Usage** | When is Check Client IP Address visible? | When policy list type is **Request** and **Validate ACL for Issuer** is on, this toggle appears in the ACL Settings panel. |

