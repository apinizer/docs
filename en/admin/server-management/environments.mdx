---
title: "Environments"
description: "You can create API Proxy runtime execution context and perform environment management. You can create production, development/test, and sandbox environments, configure environment access addresses, and perform Kubernetes namespace management."
---

## What is Environment?

<Info>
Environment is a runtime execution context for API Proxies in an installation. An API Proxy must be deployed to an environment to be accessible by one or more API Proxies. An API Proxy can be deployed to a single environment or multiple environments.
</Info>

<Note>
An environment provides an isolated area as a system resource to run API Gateways. It allows creating multiple environments in the Apinizer platform.

Environment management is performed in two ways:
- All Kubernetes definitions required for Gateway and Cache Servers are created and managed through the API Manager screen
- Only standard data of existing Kubernetes definitions are recorded in the API Manager screen
</Note>

## Environment Roles

An environment can be created in different roles as **Production**, **Development/Test**, or **Sandbox**.

The point to note here is that for a client to access an API Proxy, it must be deployed to at least one environment.
<img
  src="/images/yonetici/ortam-rolleri.png"
  alt="Environment Roles"
  width="800"
  height="500"
/>

<CardGroup cols={1}>
  <Card title="Test Environment" icon="flask">
    Used to test API Proxies or Applications active in the test environment. Testing can also be done to measure the adequacy of resources in hardware.

    If product development is done far from the test environment, it can cause problems in progress.
  </Card>
  <Card title="Sandbox Environment" icon="box">
    API Proxies and Applications active in the sandbox environment are used in the development and testing process. This environment provides the opportunity to perform safe testing without affecting the production process and close to the production process.

    It is important because it mimics the state of the product on the production environment. For example, it facilitates adding policies to the relevant API Proxy and testing before access on the production environment.
     This ensures the security of the production environment and helps eliminate the risk of a developer accidentally changing a live (production) application. It also ensures that the end user accesses after ensuring that the application works.

  </Card>
  <Warning>
  **Important Differences:**

  - The difference between **test environment and sandbox environment** can be considered. The product (API Proxy or Application) is activated on **test environment** to test during the development process, and on **sandbox environment** to simulate real users before the product is finished and released to end users
  - Installation is performed to the relevant role environment according to the usage purpose of the API Proxy. The same API Proxy can be activated on different environments for different purposes
  - Each environment works independently of others
  </Warning>
  <Card title="Production Environment" icon="rocket">
API Proxies or Applications active in the production environment are used for end users. This environment is designed to carry the load of clients.

  </Card>
</CardGroup>

## Environment Architecture

Environment is designed to be used in environments where many APIs are spread across multiple teams or projects. The Environment concept in Apinizer corresponds exactly to the namespace in Kubernetes.

The environment you create and deploy in Apinizer is created as a namespace in Kubernetes. An environment contains namespace, deployment, pod, replica set, service, and access URL components.

All environments created with the Apinizer Platform are also located within the Kubernetes cluster.

<Note>
**Kubernetes Namespace Concept:**

Kubernetes clusters can manage large amounts of unrelated workloads simultaneously. Kubernetes uses a concept called namespace to eliminate the complexity of objects within the cluster.

Namespaces enable grouping objects together and filtering and controlling these groups as a unit. Whether used to apply customized access control policies or to separate all units for a test environment, namespaces are a powerful and flexible structure for managing objects as a group.

Namespaces provide a scope for object names within the cluster. While names within a namespace must be unique, the same name can be used in different namespaces.

For detailed information, see [Kubernetes Documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/).
</Note>

## Environment Components

<AccordionGroup>
  <Accordion title="Namespace" icon="folder">
    The environment concept in the Apinizer Platform corresponds to the Namespace concept in the Kubernetes environment.
  </Accordion>

  <Accordion title="Log Server" icon="file-lines">
    Elasticsearch cluster connection definition where all API Traffic and requests in the created environment will be logged.
  </Accordion>

  <Accordion title="Deployment" icon="server">
    Two deployments are defined as Gateway Engine (Worker Server) and Cache Server:

    - **Worker Server:** Core module of the Apinizer Platform, responsible for routing all API requests to BackendAPI and works as Policy Enforcement Point
    - **Cache Server:** Environment where Cache values required in Apinizer are stored
  </Accordion>

  <Accordion title="Service" icon="network-wired">
    Environment Service is created to access the Apinizer Worker pod in Environment Deployment. Service is the layer that handles requests coming to all pods. It is located in front of pods in terms of position.

    Service information is defined when each environment is created. However, it is important that all Apinizer Workers in the cluster are managed with a service. Also, service ports in the Apinizer Platform must be unique. NodePort is used by default and service types other than this are not supported by Apinizer.
  </Accordion>

  <Accordion title="Access URL" icon="link">
    Access URL is the external access address of the Proxy. It is specified as `https://<your-IP-address>`. Messages can be sent to Proxies using external access address information.
  </Accordion>
</AccordionGroup>

## Environment Access Address

An API Proxy can be accessed through the access address of the environment it is deployed to.

### Access Address Structure

Let the access address of an API Proxy be:

```
http://demo.apinizer.com/apigateway/myproxy
```

| Component | Description |
|---------|----------|
| `http://demo.apinizer.com/` | Environment Access Address |
| `apigateway/` | Root Context |
| `myproxy` | API Proxy Relative Path |

### Access Address Configuration

The access address to be defined for the environment is generally the DNS address defined in a load balancer such as WAF or Nginx. Environments defined in Apinizer correspond to a namespace in Kubernetes. A Kubernetes service of NodePort type is automatically created by Apinizer for access to Apinizer Workers running in the namespace. A service is created with the value entered in Engine Service Port when creating the environment.

### Example Service Configuration

Example service information to access Apinizer Worker:

If the Engine Service Port value is **30080** (default value and should be different for each environment), it should be specified in the DNS definition in your WAF or Nginx server as follows:

```bash
http://kubernetes-worker-node-IP:30080/
```

