---
title: "Http Routing Configuration"
description: 'Client Route Setup, Upstream Configuration, Load Balancing Options, Path-based, Method-based, Header-based routing'
---

HTTP Routing allows you to configure how the API Proxy receives requests from clients and routes them to backend APIs. This page explains Client Route configuration, Upstream Target settings, and Load Balancing options.

## Overview

HTTP Routing configuration consists of two main components:

<CardGroup cols={2}>
  <Card title="Client Route" icon="arrow-right">
    How requests from clients are received
  </Card>
  <Card title="Upstream Target" icon="arrow-left">
    How requests are routed to backend APIs
  </Card>
</CardGroup>

## Client Route

Client Route is the routing information that clients will use to access the API Proxy. At least one routing option (Path, Method, or Header-based) must be selected.

### Path-Based Routing

Path-based routing routes based on URL path.

#### Relative Paths

Relative URL paths that will be routed to the API Proxy. Multiple paths can be defined.

**Features:**
* Each path must start with "/"
* Must be unique within the application
* Cannot be the beginning of another path

**Examples:**
```
/petstoreProxy
/api/v1/users
/products
/api/v2/orders
```

**Path Matching:**
* **Exact Match**: Exact match (e.g., `/api/users`)
* **Prefix Match**: Prefix match (e.g., `/api/*`)

#### Path Features

**Single Path:**
```
/api/users
```

**Wildcard Path:**
```
/api/users/*
/api/*/orders
```

**Versioned Path:**
```
/api/v1/users
/api/v2/users
```

### Method-Based Routing

Method-based routing routes based on HTTP method.

#### Supported Methods

* **GET**: Data reading operations
* **POST**: Creating new records
* **PUT**: Record update (full update)
* **DELETE**: Record deletion
* **PATCH**: Partial update
* **OPTIONS**: CORS preflight requests
* **HEAD**: Getting header information

#### Method Selection

By default, all methods can be selected. If you want to route for specific methods, select only those methods.

**Example:**
```
GET, POST → Read/Write API
GET → Read-only API
POST, PUT, DELETE → Write API
```

### Header-Based Routing

Header-based routing routes based on HTTP headers.

#### Header Matching

For header-based routing:

* **Header Name**: Header name to match
* **Header Value**: Header value to match (optional)
* **Match Type**: Match type (exact, prefix, regex)

**Examples:**
```
X-API-Version: v1
Content-Type: application/json
X-Client-Type: mobile
```

#### Header Routing Scenarios

**API Version Header:**
```
Header: X-API-Version
Value: v1
→ Routes to v1 backend
```

**Client Type Header:**
```
Header: X-Client-Type
Value: mobile
→ Routes to mobile-optimized backend
```

### Host-Based Routing

Host-based routing routes based on HTTP Host header.

#### Host Matching

**Examples:**
```
api.example.com → Production API
api-staging.example.com → Staging API
api-dev.example.com → Development API
```

## Upstream Target

Upstream Target is the address and configuration of the backend API.

### Upstream Target Configuration

#### Backend URL

Base URL of the backend API.

**Format:**
```
http://host:port
https://host:port
```

**Examples:**
```
https://api.example.com
http://localhost:8080
https://api.example.com:8443
```

#### Multiple Upstream Targets

Multiple upstream targets can be defined. In this case, load balancing is used.

**Usage Scenarios:**
* **Load Balancing**: Load distribution
* **Failover**: Backup
* **Blue-Green Deployment**: Blue-green deployment
* **Canary Deployment**: Canary deployment

### Load Balancing

If there are multiple upstream targets, a load balancing strategy can be selected.

#### Load Balancing Strategies

**Round Robin:**
* Requests are distributed sequentially
* Equal load distribution to each target
* Simple and effective

**Least Connections:**
* Routes to the target with least connections
* Dynamic load distribution
* Suitable for slow backends

**IP Hash:**
* Hash based on client IP
* Same client goes to same target
* Provides session affinity

**Weighted:**
* Weights are assigned to targets
* More requests to higher weighted targets
* Suitable for backends with different capacities

#### Load Balancing Examples

**Round Robin:**
```
Target 1: https://api1.example.com (Weight: 1)
Target 2: https://api2.example.com (Weight: 1)
Target 3: https://api3.example.com (Weight: 1)
→ Requests are distributed sequentially
```

**Weighted:**
```
Target 1: https://api1.example.com (Weight: 3)
Target 2: https://api2.example.com (Weight: 2)
Target 3: https://api3.example.com (Weight: 1)
→ 3x requests to Target 1, 2x to Target 2, 1x to Target 3
```

### Health Check

Health check configuration to check the health status of upstream targets.

#### Health Check Settings

* **Enable Health Check**: Enable health check
* **Health Check Path**: Health check endpoint (e.g., `/health`)
* **Health Check Interval**: Check interval (seconds)
* **Health Check Timeout**: Timeout duration (seconds)
* **Unhealthy Threshold**: Threshold for unhealthy status
* **Healthy Threshold**: Threshold for healthy status

#### Health Check Examples

**Simple Health Check:**
```
Path: /health
Interval: 10s
Timeout: 5s
```

**Advanced Health Check:**
```
Path: /api/health
Interval: 30s
Timeout: 10s
Unhealthy Threshold: 3
Healthy Threshold: 2
```

### Failover

Automatic switching to another target when an upstream target fails.

#### Failover Configuration

* **Enable Failover**: Enable failover
* **Failover Strategy**: Failover strategy
  * **Next Available**: Next available target
  * **Round Robin**: According to round robin order
  * **Priority Based**: According to priority order

#### Failover Scenarios

**Primary-Backup:**
```
Primary: https://api1.example.com
Backup: https://api2.example.com
→ Switches to Backup if Primary fails
```

**Multiple Backups:**
```
Primary: https://api1.example.com
Backup 1: https://api2.example.com
Backup 2: https://api3.example.com
→ Switches to backups sequentially
```

## Routing Combinations

Different routing options can be used together.

### Path + Method

Path and method combination:

```
Path: /api/users
Method: GET, POST
→ GET and POST requests for /api/users
```

### Path + Header

Path and header combination:

```
Path: /api/*
Header: X-API-Version: v1
→ /api/* requests with v1 header
```

### Method + Header

Method and header combination:

```
Method: POST
Header: Content-Type: application/json
→ JSON POST requests
```

## Usage Scenarios

### Scenario 1: Simple REST API

Routing for a simple REST API:

**Client Route:**
* Path: `/api/users`
* Methods: GET, POST, PUT, DELETE

**Upstream Target:**
* URL: `https://api.example.com`
* Load Balancing: None (Single target)

### Scenario 2: Load Balanced API

Routing for load balanced API:

**Client Route:**
* Path: `/api/products`
* Methods: GET, POST

**Upstream Targets:**
* Target 1: `https://api1.example.com`
* Target 2: `https://api2.example.com`
* Target 3: `https://api3.example.com`
* Load Balancing: Round Robin
* Health Check: Enabled

### Scenario 3: Versioned API

Routing for versioned API:

**Client Route:**
* Path: `/api/v1/*`
* Header: `X-API-Version: v1`

**Upstream Target:**
* URL: `https://api-v1.example.com`

**Client Route (v2):**
* Path: `/api/v2/*`
* Header: `X-API-Version: v2`

**Upstream Target:**
* URL: `https://api-v2.example.com`

### Scenario 4: Multi-Environment Routing

Multi-environment routing:

**Development:**
* Host: `api-dev.example.com`
* Upstream: `http://localhost:8080`

**Staging:**
* Host: `api-staging.example.com`
* Upstream: `https://api-staging.example.com`

**Production:**
* Host: `api.example.com`
* Upstream: `https://api.example.com` (Load balanced)

## Best Practices

### Path Design

* **RESTful Convention**: Follow RESTful conventions
* **Versioning**: Use paths for versioning (`/api/v1/`, `/api/v2/`)
* **Unique Paths**: Ensure paths are unique within the application
* **Descriptive Paths**: Keep paths descriptive and understandable

### Load Balancing

* **Health Check**: Always keep health check active
* **Strategy Selection**: Choose appropriate strategy according to needs
* **Weighted Balancing**: Use weighted for backends with different capacities
* **Failover**: Configure failover

### Upstream Target

* **HTTPS**: Use HTTPS in production
* **Connection Pooling**: Optimize connection pooling
* **Timeout**: Set timeout values appropriately
* **Monitoring**: Monitor upstream targets

## Next Steps

<CardGroup cols={2}>
  <Card title="gRPC Routing" icon="network-wired" href="/en/developer/grpc-routing">
    gRPC routing configuration
  </Card>
  <Card title="WebSocket Routing" icon="globe" href="/en/developer/websocket-routing">
    WebSocket routing configuration
  </Card>
  <Card title="API Proxy Configuration" icon="gear" href="/en/developer/api-proxy-configuration/overview">
    API Proxy configuration
  </Card>
  <Card title="Load Balancing" icon="balance-scale" href="/en/developer/http-routing#load-balancing">
    Load balancing details
  </Card>
</CardGroup>
