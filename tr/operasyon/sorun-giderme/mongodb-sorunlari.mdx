---
title: "MongoDB Olası Sorunları ve Çözümleri"
description: "MongoDB kurulumları ve kullanımları sırasında karşılaşılabilecek yaygın sorunları ve çözümlerini sağlar. CentOS kurulum hataları, disk kullanımı, proje ve proxy silme işlemleri, hostname değişiklikleri gibi konularda pratik çözümler sunar."
---

<AccordionGroup>
  <Accordion title="CentOS 7 üzerinde MongoDB kurulumunda hata alınırsa">
    <p><strong>Sebep/Neden:</strong> warning: /var/cache/yum/x86_64/7/MongoDB/packages/mongodb-org-mongos-4.2.13-1.el7.x86_64.rpm: Header V3 RSA/SHA1 Signature, key ID 058f8b6b: NOKEY</p>
    
    <p>Retrieving key from <a href="https://www.mongodb.org/static/pgp/server-4.2.asc">https://www.mongodb.org/static/pgp/server-4.2.asc</a></p>
    
    <p><strong>Çözüm:</strong> Aşağıdaki dosyada <code>gpgcheck=0</code> yapmak</p>

```bash
sudo vi /etc/yum.repos.d/mongodb.repo
```

```ini
[MongoDB]
name=MongoDB Repository
baseurl=http://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/$basearch/
gpgcheck=0
enabled=1
gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc
```
  </Accordion>

  <Accordion title="CentOS 8 üzerinde MongoDB kurulumunda hata alınırsa">
    <p><strong>Sebep/Neden:</strong> Eğer "systemctl status mongodb.service -l" komutunda aşağıdaki gibi bir çıktı görüyorsanız:</p>

```bash
SELinux is preventing /usr/bin/mongod from read access on the file snmp.
```

    <p><strong>Çözüm:</strong> Aşağıdaki komutları çalıştırın ve mongodb.service durumunu hatalar kaybolana kadar kontrol edin:</p>

```bash
grep mongod /var/log/audit/audit.log | audit2allow -M mypol
semodule -i mypol.pp
grep ftdc /var/log/audit/audit.log | audit2allow -M mypol
semodule -i mypol.pp
```
  </Accordion>

  <Accordion title="/var/lib/mongodb yolunun çok fazla miktarda yer kaplaması">
    <p><strong>Sebep/Neden:</strong> Bu bir problem olmamakla birlikte bazı durumlarda yetersiz disk ve dolayısıyla sistem işleyişine etki edebilmektedir. Özellikle journaling açıksa ve replicaset'te çok node'lu yapı kullanılıyorsa bu durum görülebilir.</p>
    
    <p><strong>Çözüm:</strong></p>

    <p><strong>Çoklu Node kullanımlarda:</strong> Çalışan mongod servislerinden biri kapatılarak primary'nin bir başka sunucudaki mongo'ya geçmesi beklenir. Sonrasında /var/lib/mongodb yolundaki tüm dosyalar silinir. Mongod servisi baştan başlatıldığında otomatik senkronizasyon ile sadece gerekli dosyalar oluşturulacaktır. <strong>Operasyonlarda kesintiye yol açmaz.</strong></p>

    <p><strong>Tek Node kullanımlarda:</strong> <strong>Operasyonlarda kesinti yapılarak gerçekleştirilebilir.</strong> Mevcut veritabanının yedeği alınır, çalışan manager durdurulur, veritabanı drop edilir, /var/lib/mongodb yolu temizlenir, mongo geri yüklenir, manager tekrar çalıştırılır.</p>
  </Accordion>

  <Accordion title="Bir projenin ve içindeki proxy'lerin manuel olarak silinme ihtiyacı olursa">
    <p><strong>Sebep/Neden:</strong> Bu bir problem olmamakla birlikte bunlar manuel olarak silinmek istenirse uygulanabilir.</p>
    
    <p><strong>Çözüm:</strong> Çözüm için sırasıyla aşağıdaki adımlar izlenebilir:</p>

    <p><strong>1. Mevcut projelerdeki id'leri al ve string'e çevir:</strong></p>

```javascript
var validProjectIds = db.project.find({}, {_id: 1}).toArray().map(function(item){ return item._id.toString(); });
```

    <p><strong>2. API proxy'ler üzerinde gezerek karşılığı mevcut olmayan proje id'lerini bul:</strong></p>

```javascript
var invalidProjectIds = [];
db.api_proxy.find({}).forEach(function(doc) {
    if( doc.projectId && doc.projectId!=='admin' && !validProjectIds.includes(doc.projectId.toString())) {
        if( !invalidProjectIds.includes(doc.projectId.toString())) {
            invalidProjectIds.push(doc.projectId);
        }
    }
});
```

    <p><strong>3. İlişkisi olmayan api_proxy'ları sil:</strong></p>

```javascript
invalidProjectIds.forEach(function(invalidProjectId) {
    db.api_proxy.deleteMany({projectId: invalidProjectId});
});
```
  </Accordion>

  <Accordion title="Bir projeye admin kullanıcısını proje sahibi olarak eklemek">
    <p><strong>Sebep/Neden:</strong> Bu bir problem olmamakla birlikte projeye hızlı erişim gerektiği durumlarda uygulanabilir.</p>
    
    <p><strong>Çözüm:</strong></p>

```javascript
// Apinizer veritabanına geçilir
use apinizerdb

// Aşağıdaki komut çalıştırılır ve gelen ObjectId değerinin içeriği alınır
db.role.find({name:"Project Owner"}, {_id:1})

// Alınan değer aşağıdaki komutta <OBJECT_ID> alanına yazılır ve <PROJECT_NAME> alanına istenilen proje adı yazılarak komut çalıştırılır
db.project.updateOne(
    { name:"<PROJECT_NAME>" },
    {
        $push: {
            "projectMember.teamMemberList": {
                userId: "admin",
                roleList: [
                    {
                        $ref: "role",
                        $id: ObjectId("<OBJECT_ID>")
                    }
                ]
            }
        }
    }
)
```
  </Accordion>

  <Accordion title="MongoDB Cluster'ındaki Node'un Hostname'i Değişecekse">
    <Warning>
      <strong>Çalışma Öncesi Dikkat Edilmesi Gerekenler:</strong>
      <ul>
        <li>Bu işlemler MongoDB replicaset'indeki hata tolerasyonuna dikkat edilerek yapılmalıdır aksi takdirde kesintiler yaşanabilmektedir (MongoDB (n-1)/2 tolerasyonu)</li>
        <li>Bu tür bir işlem öncesinde tam bir sistem yedeği alınması önerilmektedir.</li>
      </ul>
    </Warning>

    <p><strong>Sebep/Neden:</strong> MongoDB cluster'da hali hazırda çalışan bir node'un hostname'i değiştirildiğinde, bazı yapılandırmalar ve kimlik bilgileri eski hostname ile çakışabilmektedir. Bu yüzden bu işlemi yaparken replicaset'te hostname'i değiştirilecek node çıkartılıp hostname bilgisi değiştikten sonra eklenmelidir.</p>
    
    <p><strong>Çözüm:</strong></p>

    <p><strong>1. Çalışma Öncesi MongoDB Backup Alınır:</strong> Primary node'a bağlanılır ve Apinizer'ın MongoDB veritabanı yedeği alınır.</p>

```bash
mongosh mongodb://localhost:25080 --authenticationDatabase "admin" -u "apinizer" -p
show dbs
use apinizerdb

# Veritabanındaki yüksek boyutlu koleksiyonlar kontrol edilir
db.getCollectionNames().map(name => ({storageSizeMB: (db.getCollection(name).stats().storageSize / (1024*1024)).toFixed(2), name: name})).sort((a,b) => a.storageSizeMB - b.storageSizeMB).forEach(printjson);

# Eğer yüksek boyutlu koleksiyon var ise ve yedek alınmak istemiyorsa --excludeCollection <Collection_Name> parametresi kullanılabilir
sudo mongodump --host localhost --port=25080 --username=apinizer --password=passwd -d apinizerdb --authenticationDatabase=admin --gzip --archive=/home/apinizer/mongodump/apinizer-backup-v<Apinizer Version>-<Date>--1.archive
```

    <p><strong>2. Hostname'in Değişeceği Node MongoDB Replicaset'ten Çıkarılır:</strong></p>

```bash
mongosh mongodb://localhost:25080 --authenticationDatabase "admin" -u "apinizer" -p
rs.status()

# Eğer sunucu primary node ise önce secondary'e çevrilir ve yeni primary'e bağlanılır (rs.stepDown())
rs.remove("<NODES_OLD_HOSTNAME>")
rs.status()

# Hostname'i değiştirilecek sunucuya bağlanılır mongodb servisi durdurulur
sudo systemctl stop mongod
sudo hostnamectl set-hostname <NODES_NEW_HOSTNAME>
sudo reboot

hostname
# /etc/hosts üzerinde 127.0.0.1 ip'sine karşılık eski hostname duruyorsa bu kısım yeni hostname ile değiştirilmelidir
sudo vi /etc/hosts
sudo systemctl start mongod

# Primary sunucuya bağlanılır ve hostname'i değişen node replica set'e dahil edilir
rs.add("<NODES_NEW_HOSTNAME>")

# Veri senkronizasyonunun tamamlanması beklenilir
rs.status()
```
  </Accordion>
</AccordionGroup>
