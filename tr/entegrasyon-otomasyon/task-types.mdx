---
title: 'Task Types'
description: 'Task Flow\'larda Sequential, Parallel ve Decision task türlerini anlama ve ne zaman kullanılacağı'
---

Task Flow'lar, çalışma akışını kontrol etmek için farklı task türlerini destekler. Bu task türlerini anlamak, verimli ve güvenilir entegrasyon iş akışları tasarlamak için gereklidir.

## Genel Bakış

Task türleri, Task Flow'da task'ların nasıl çalıştırılacağını belirler. Apinizer üç ana task türünü destekler: Sequential, Parallel ve Decision.

<CardGroup cols={2}>
  <Card title="Sequential Tasks" icon="arrow-right">
    Task'ları birbiri ardına çalıştırın
  </Card>
  <Card title="Parallel Tasks" icon="layer-group">
    Birden fazla task'ı aynı anda çalıştırın
  </Card>
  <Card title="Decision Tasks" icon="code-branch">
    Koşullu task çalıştırma
  </Card>
</CardGroup>

## Sequential Tasks

Sequential task'lar, doğrusal bir sırada birbiri ardına çalıştırılır. Her task, başlamadan önce önceki task'ın tamamlanmasını bekler.

### Özellikler

* **Sıra Önemli**: Task'lar tanımlandıkları sırayla çalıştırılır
* **Bağımlılık**: Her task önceki task'ların çıktısını kullanabilir
* **Hata Yayılımı**: Bir task başarısız olursa, sonraki task'lar çalışmayabilir
* **Basit Akış**: Anlamak ve debug etmek kolaydır

### Kullanım Senaryoları

**Veri Pipeline'ı:**

```
1. Kaynaktan veri çek (Database Connector)
2. Veriyi dönüştür (Script Connector)
3. Veriyi doğrula (Script Connector)
4. Hedefe kaydet (Database Connector)
```

**API Zinciri:**

```
1. Kimlik doğrula (HTTP Connector)
2. Kullanıcı bilgilerini al (HTTP Connector)
3. Kullanıcı verilerini işle (Script Connector)
4. Bildirim gönder (Email Connector)
```

### Örnek Yapılandırma

**Sequential Akış:**

```
Start → Task 1 → Task 2 → Task 3 → End
```

**Çalıştırma Sırası:**

1. Task 1 çalıştırılır
2. Task 1 tamamlandıktan sonra Task 2 çalıştırılır
3. Task 2 tamamlandıktan sonra Task 3 çalıştırılır

### Avantajlar

* Tasarım ve anlama açısından basit
* Debug etmek kolay (doğrusal çalıştırma)
* Öngörülebilir çalıştırma sırası
* Bağımlı işlemler için doğal

### Dezavantajlar

* Daha yavaş çalıştırma (task'lar birbirini bekler)
* Bağımsız işlemler için optimal değil
* Sıralı darboğaz

## Parallel Tasks

Parallel task'lar aynı anda çalıştırılır ve birden fazla işlemin aynı anda çalışmasına izin verir. Bu, task'lar bağımsız olduğunda performansı artırır.

### Özellikler

* **Eşzamanlı Çalıştırma**: Birden fazla task aynı anda çalışır
* **Bağımsızlık**: Task'lar birbirine bağımlı olmamalıdır
* **Senkronizasyon**: Devam etmeden önce tüm task'lar tamamlanır
* **Performans**: Daha hızlı genel çalıştırma

### Kullanım Senaryoları

**Bağımsız İşlemler:**

```
Parallel Branch:
  ├─ Kullanıcı verilerini çek (HTTP Connector)
  ├─ Sipariş verilerini çek (HTTP Connector)
  ├─ Ürün verilerini çek (HTTP Connector)
  └─ Hepsi tamamlandı → Sonuçları birleştir
```

**Çoklu Bildirimler:**

```
Parallel Branch:
  ├─ E-posta bildirimi gönder (Email Connector)
  ├─ SMS bildirimi gönder (HTTP Connector)
  ├─ Veritabanına logla (Database Connector)
  └─ Hepsi tamamlandı → Devam et
```

### Örnek Yapılandırma

**Parallel Akış:**

```
Start → Parallel Node
         ├─ Task A
         ├─ Task B
         └─ Task C
      → Merge → End
```

**Çalıştırma:**

* Task A, B ve C aynı anda başlar
* Tüm task'lar eşzamanlı olarak çalıştırılır
* Akış tüm task'ların tamamlanmasını bekler
* Tüm task'lar bittikten sonra çalıştırma devam eder

### Avantajlar

* Bağımsız task'lar için daha hızlı çalıştırma
* Daha iyi kaynak kullanımı
* Geliştirilmiş throughput
* I/O-bound işlemler için uygun

### Dezavantajlar

* Daha karmaşık hata yönetimi
* Senkronizasyon gerektirir
* Daha fazla kaynak tüketebilir
* Debug etmek daha zor

### En İyi Uygulamalar

* Bağımsız işlemler için parallel task'lar kullanın
* Task'ların bağımlılıkları olmadığından emin olun
* Her parallel dalda hataları yönetin
* Kaynak limitlerini göz önünde bulundurun
* Parallel çalıştırma performansını izleyin

## Decision Tasks

Decision task'lar, koşullara dayalı koşullu çalıştırma sağlar. Task Flow'larda dallanma mantığını (IF-THEN-ELSE) etkinleştirirler.

### Özellikler

* **Koşullu Mantık**: Koşullara göre task'ları çalıştırın
* **Dallanma**: Birden fazla çalıştırma yolu
* **Boolean Değerlendirme**: Koşullar true/false olarak değerlendirilir
* **Esnek Akış**: Dinamik çalıştırma yolları

### Kullanım Senaryoları

**Koşullu İşleme:**

```
Decision: customer.status === 'premium'
  ├─ True → Premium indirim uygula (Script Connector)
  └─ False → Standart fiyatlandırma uygula (Script Connector)
```

**Hata Yönetimi:**

```
Decision: order.total > 1000
  ├─ True → Onay gerektir (Email Connector)
  └─ False → Otomatik onayla (Database Connector)
```

**Veri Doğrulama:**

```
Decision: isValid(data)
  ├─ True → Veriyi işle (Database Connector)
  └─ False → Hata bildirimi gönder (Email Connector)
```

### Örnek Yapılandırma

**Decision Akışı:**

```
Start → Decision Node
         ├─ Condition: ${customer.balance} > 1000
         ├─ True Path → Task A
         └─ False Path → Task B
      → Merge → End
```

**Koşul Sözdizimi:**

```javascript
// Basit karşılaştırma
${variable} === 'value'
${number} > 100

// Karmaşık koşullar
${customer.status} === 'active' && ${customer.balance} > 0
${order.items.length} > 0 || ${order.total} > 100

// Fonksiyon çağrıları
isValid(${data})
contains(${array}, 'value')
```

### Koşul Türleri

**Karşılaştırma Operatörleri:**

* `===` Eşittir
* `!==` Eşit değildir
* `>` Büyüktür
* `<` Küçüktür
* `>=` Büyük veya eşittir
* `<=` Küçük veya eşittir

**Mantıksal Operatörler:**

* `&&` AND
* `||` OR
* `!` NOT

**String İşlemleri:**

* `contains(string, substring)`
* `startsWith(string, prefix)`
* `endsWith(string, suffix)`
* `matches(string, regex)`

**Dizi İşlemleri:**

* `contains(array, value)`
* `length(array) > 0`
* `isEmpty(array)`

### Avantajlar

* Esnek çalıştırma yolları
* Dinamik akış kontrolü
* Koşullu işleme
* Hata yönetimi yetenekleri

### Dezavantajlar

* Daha karmaşık akış tasarımı
* Dikkatli koşul tasarımı gerektirir
* Test edilecek birden fazla yol
* Mantık hataları potansiyeli

## Task Türlerini Birleştirme

Karmaşık iş akışları oluşturmak için farklı task türlerini birleştirebilirsiniz:

### Sequential ile Parallel

```
Start → Task 1 → Parallel Node
                  ├─ Task A
                  ├─ Task B
                  └─ Task C
               → Task 2 → End
```

### Parallel ile Decision

```
Start → Parallel Node
         ├─ Task A
         ├─ Task B
         └─ Task C
      → Decision Node
         ├─ True → Task D
         └─ False → Task E
      → End
```

### İç İçe Decision'lar

```
Start → Decision 1
         ├─ True → Decision 2
         │         ├─ True → Task A
         │         └─ False → Task B
         └─ False → Task C
      → End
```

## En İyi Uygulamalar

<CardGroup cols={2}>
  <Card title="Uygun Türü Seçin" icon="check-circle">
    Bağımlılıklara ve gereksinimlere göre task türünü seçin
  </Card>
  <Card title="Parallel Karmaşıklığını Minimize Edin" icon="layer-group">
    Parallel dalları basit ve bağımsız tutun
  </Card>
  <Card title="Açık Koşullar" icon="code-branch">
    Decision task'lar için açık, test edilebilir koşullar yazın
  </Card>
  <Card title="Hata Yönetimi" icon="shield-halved">
    Her task türü için uygun şekilde hataları yönetin
  </Card>
  <Card title="Performans Düşüncesi" icon="gauge">
    Performansı artırmak için bağımsız işlemler için parallel task'lar kullanın
  </Card>
  <Card title="Test Etme" icon="flask">
    Özellikle decision dalları olmak üzere tüm çalıştırma yollarını test edin
  </Card>
</CardGroup>

## Performans Düşünceleri

### Sequential Tasks

* **Ne Zaman Kullanılır**: Task'lar bağımlılıklara sahipse
* **Performans**: Daha yavaş ama öngörülebilir
* **Kaynak Kullanımı**: Daha düşük kaynak tüketimi
* **En İyi Kullanım**: Veri pipeline'ları, bağımlı işlemler

### Parallel Tasks

* **Ne Zaman Kullanılır**: Task'lar bağımsızsa
* **Performans**: Daha hızlı çalıştırma
* **Kaynak Kullanımı**: Daha yüksek kaynak tüketimi
* **En İyi Kullanım**: Bağımsız API çağrıları, parallel bildirimler

### Decision Tasks

* **Ne Zaman Kullanılır**: Koşullu mantık gerekiyorsa
* **Performans**: Minimal overhead
* **Kaynak Kullanımı**: Düşük
* **En İyi Kullanım**: Koşullu işleme, hata yönetimi

## İlgili Konular

<CardGroup cols={2}>
  <Card title="Task Flow Tasarımı" icon="diagram-project" href="/tr/entegrasyon-otomasyon/task-flow-tasarimi">
    Task Flow tasarımını öğrenin
  </Card>
  <Card title="Variables & Data Passing" icon="arrows-rotate" href="/tr/entegrasyon-otomasyon/variables-data-passing">
    Değişken yönetimini anlayın
  </Card>
  <Card title="Performance Optimization" icon="gauge" href="/tr/entegrasyon-otomasyon/performance-optimization">
    Task Flow performansını optimize edin
  </Card>
  <Card title="Error Handling & Retries" icon="rotate-right" href="/tr/entegrasyon-otomasyon/error-handling-retries">
    Hata yönetimi stratejilerini yapılandırın
  </Card>
</CardGroup>
