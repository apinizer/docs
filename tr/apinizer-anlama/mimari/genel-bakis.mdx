---
title: "Mimari"
description: "Apinizer platformunun teknik mimarisi: temel bileşenler, dağıtım esnekliği, ölçeklenebilirlik ve entegrasyon mimarisi"
---

Bu sayfa, Apinizer platformunun teknik mimarisini kapsamlı bir şekilde açıklar. Platformun mimari yaklaşımı, bileşenleri, dağıtım esnekliği, ölçeklenebilirlik ve entegrasyon yetenekleri hakkında detaylı bilgiler içerir.

## 1. Temel Mimari Yaklaşım ve Bileşenler

Apinizer platformu, modern API Management gereksinimlerini karşılamak üzere tasarlanmış, modüler ve dağıtık bir mimariye sahiptir.

### Mimari Tipi

Apinizer, **modüler**, **dağıtık** ve **yatay ölçeklenebilir (Horizontally Scalable)** bir mimariye sahiptir. Bu mimari sayesinde:

* Bileşenler bağımsız olarak ölçeklendirilebilir
* Yüksek trafikli ortamlarda performans sorunları yaşanmaz
* Kaynak kullanımı optimize edilir
* Sistem kesintisiz çalışabilir

### Temel Bileşenler (High-Level)

Apinizer platformu aşağıdaki temel bileşenlerden oluşur:

#### API Manager (Yönetim Konsolu)

API'lerin tasarlandığı, konfigürasyonların yapıldığı ve sistemin yönetildiği merkezi arayüzdür. Control Plane (Yönetim Düzlemi) olarak da adlandırılır.

<CardGroup cols={2}>
  <Card title="Web API Manager" icon="globe">
    Ayarların/Tanımlamaların bir Web tarayıcı üzerinden form tabanlı arayüzler aracılığı ile yapılabilmesini, bu ayarların diğer bileşenlere gönderilebilmesini sağlar.
  </Card>
  <Card title="Management API" icon="code">
    Uygulama üzerinden yapılabilecek ayarların API'ler ile yapılmasını sağlar.
  </Card>
  <Card title="Analytics" icon="chart-bar">
    Tutulan log kayıtlarındaki analitik verilerin görselleştirilmesini ve sorgulanabilmesini sağlar.
  </Card>
  <Card title="Monitoring" icon="heart-pulse">
    API Proxy'lerin çalışıp çalışmadığını kontrol eder, çalışmadığını tespit ederse alarm oluşturur.
  </Card>
  <Card title="Anomaly Detection" icon="triangle-exclamation">
    API Proxy'lerin çalışmasında anormal bir durum olup olmadığını kontrol eder, anormal durum tespit ederse alarm oluşturur.
  </Card>
  <Card title="Alarms & Actions" icon="bell">
    Monitoring veya Anomaly Detection ile oluşan alarmların eyleme dönüştürülmesi sağlar.
  </Card>
  <Card title="Scheduled Jobs" icon="clock">
    Zamanlanmış görevlerin tetiklenmesini sağlar.
  </Card>
  <Card title="Test Console" icon="flask">
    Dahili ya da harici API'lerin test edilebilmesi için geliştirme ortamını terk etmeden ve başka bir yazılıma ihtiyaç duymadan kullanılabilecek test aracıdır.
  </Card>
</CardGroup>

#### API Gateway (Veri Düzlemi)

API trafiğinin geçtiği, politikaların uygulandığı, yüksek performanslı bileşendir. Manager'dan bağımsız ölçeklenebildiği vurgulanmalıdır. Data Plane olarak da adlandırılır.

<CardGroup cols={2}>
  <Card title="Proxy Handler (Policy Enforcement Point)" icon="network-wired">
    İstemcilerden gelen isteklerin karşılandığı noktadır. Aynı zamanda Politika Uygulama Noktası (Policy Enforcement Point) olarak görev yapar. Gelen isteği tanımlanmış politikalara uygun şekilde işleyerek ilgili Backend API/Servise yönlendirir. TLS/SSL sonlandırması burada yapılır.
    
    **Politika ve İşleme Özellikleri:**
    * Authentication (Kimlik Doğrulama)
    * Authorization (Yetkilendirme)
    * Rate Limit (Hız Sınırlama)
    * Traffic Management (Trafik Yönetimi)
    * Load Balancing (Yük Dengeleme)
    * Validation (Doğrulama)
    * Data Manipulation (Veri Manipülasyonu)
    * Business Rule (İş Kuralı)
    * Script (JavaScript/Groovy)
    * SOAP-REST Transformation
    * API Call
    * Mock (Sahte API Yanıtları)
    * Redaction (Veri Maskeleme)
  </Card>
  <Card title="Local Cache" icon="memory">
    Management API üzerinden yüklenen tüm veriler Local Cache içinde tutulur. Worker, açılış ya da yeniden başlatma sırasında kendisine ait verileri MongoDB veri tabanından çekerek Local Cache'e koyar.
  </Card>
  <Card title="Cache" icon="layer-group">
    Önbellekleme politikaları ile performans optimizasyonu sağlar. Sık kullanılan verilerin önbellekte tutulması ile yanıt süreleri kısaltılır.
  </Card>
  <Card title="Monitor & Analytics" icon="chart-bar">
    İstek/yanıt trafiğini izler ve analitik veriler toplar. Bu veriler log connectorler aracılığıyla analitik sistemlere gönderilir.
  </Card>
  <Card title="Token Provider API" icon="key">
    OAuth2 ve JWT token üretimi ve yönetimi için kullanılan API endpoint'i. Token alma isteği ile ilgili kayıtlar Log sunucusunda kayıt altına alınır.
  </Card>
  <Card title="Db-2-Api" icon="database">
    Tanımlanan bir veri tabanına bağlantı kurarak tanımlı SQL'lerin işletilmesini ya da Stored Procedure'lerin çalıştırılmasını sağlar.
  </Card>
  <Card title="Script2API" icon="file-code">
    Tanımlı JavaScript veya Groovy Script'lerin çalıştırılmasını sağlar.
  </Card>
  <Card title="MockAPI" icon="wand-magic-sparkles">
    Tanımlanan koşullara göre önceden hazırlanmış yanıtların döndürülmesini sağlar.
  </Card>
</CardGroup>

**Data Plane Özellikleri:**
* Yüksek performans ve düşük gecikme
* Otomatik ölçeklendirme (Auto-scaling)
* Yüksek erişilebilirlik (High Availability)
* TLS/SSL sonlandırması
* Trafik yönetimi ve yük dengeleme
* Manager'dan bağımsız ölçeklenebilme

#### Veritabanı (Metadata)

Konfigürasyon ve meta verilerin tutulduğu bileşendir. Apinizer, MongoDB ve PostgreSQL gibi popüler veritabanlarını destekler.

**MongoDB Kullanımı:**
* API Proxy tanımları
* Politika konfigürasyonları
* Ortam (Environment) ayarları
* Kullanıcı ve rol tanımları
* Token kayıtları (OAuth2)
* Audit log kayıtları

**Veritabanı Gereksinimleri:**
* Replica Set yapılandırması (tek node dahi olsa)
* Standalone Instance kullanılmamalıdır
* Yüksek erişilebilirlik için en az 3 node önerilir

#### Log ve Analitik Veri Yönetimi

Apinizer platformu, API trafik loglarını ve analitik verilerini yönetmek için esnek bir log gönderim mekanizmasına sahiptir. Log verileri, connectorler vasıtasıyla farklı hedeflere gönderilebilir.

**Elasticsearch (Birinci Tercih):**
* API Manager içinde veri görselleştirme ve analiz yapılabilmesi nedeniyle birinci tercih olarak önerilir
* API Traffic Logs (istek/yanıt log'ları)
* Performans metrikleri
* Hata kayıtları
* Kullanım metrikleri ve trend analizleri
* Index lifecycle management (ILM) politikaları
* Yedekleme ve snapshot stratejileri

**Alternatif Log Hedefleri (Connectorler):**
* **Database Connector**: Veritabanı sistemlerine log gönderimi
* **Kafka Connector**: Yüksek hacimli log akışı için mesajlaşma sistemi
* **RabbitMQ Connector**: Mesaj kuyruğu yönetimi
* **ActiveMQ Connector**: Apache ActiveMQ entegrasyonu
* **Syslog Connector**: Syslog protokolü ile log gönderimi
* **Webhook Connector**: Olay tabanlı bildirimler
* **Graylog Connector**: Graylog entegrasyonu

**Log Yönetimi Özellikleri:**
* Ortam bazında log connector tanımlama
* Birden fazla connector ile eşzamanlı loglama
* Failover mekanizması ile log kaybının önlenmesi
* Kapasite planlama ve ölçeklendirme

### Mimari Düzlemler

Apinizer platformu, modern API Management mimarisine uygun olarak **Data Plane** (Gateway) ve **Control Plane** (Management) olmak üzere iki ana düzlemden oluşur.

```
                    ┌─────────────────────────────────────┐
                    │      CLIENT APPLICATIONS             │
                    │  (Mobile, Web, IoT, etc.)            │
                    └─────────────────────────────────────┘
                                    │
                                    │ API Requests
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                    CONTROL PLANE                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Web Manager  │  │ Management   │  │  Analytics    │     │
│  │              │  │    API       │  │   Engine      │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Monitoring   │  │  Scheduled   │  │  Test Console │     │
│  │ & Alerting   │  │    Jobs      │  │               │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ Configuration & Control
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    DATA PLANE                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   Worker 1   │  │   Worker 2   │  │   Worker N    │     │
│  │ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │     │
│  │ │  Proxy   │ │  │ │  Proxy   │ │  │ │  Proxy   │ │     │
│  │ │ Handler  │ │  │ │ Handler  │ │  │ │ Handler  │ │     │
│  │ │  (PEP)   │ │  │ │  (PEP)   │ │  │ │  (PEP)   │ │     │
│  │ │          │ │  │ │          │ │  │ │          │ │     │
│  │ │ Auth     │ │  │ │ Auth     │ │  │ │ Auth     │ │     │
│  │ │ Authz    │ │  │ │ Authz    │ │  │ │ Authz    │ │     │
│  │ │ RateLimit│ │  │ │ RateLimit│ │  │ │ RateLimit│ │     │
│  │ │ Traffic  │ │  │ │ Traffic  │ │  │ │ Traffic  │ │     │
│  │ │ LoadBal  │ │  │ │ LoadBal  │ │  │ │ LoadBal  │ │     │
│  │ │ Validate │ │  │ │ Validate │ │  │ │ Validate │ │     │
│  │ │ DataManip│ │  │ │ DataManip│ │  │ │ DataManip│ │     │
│  │ │ Script   │ │  │ │ Script   │ │  │ │ Script   │ │     │
│  │ │ Mock     │ │  │ │ Mock     │ │  │ │ Mock     │ │     │
│  │ │ Cache    │ │  │ │ Cache    │ │  │ │ Cache    │ │     │
│  │ │ Monitor  │ │  │ │ Monitor  │ │  │ │ Monitor  │ │     │
│  │ │ Analytics│ │  │ │ Analytics│ │  │ │ Analytics│ │     │
│  │ │ Log      │ │  │ │ Log      │ │  │ │ Log      │ │     │
│  │ │ Transform│ │  │ │ Transform│ │  │ │ Transform│ │     │
│  │ │ API Call │ │  │ │ API Call │ │  │ │ API Call │ │     │
│  │ │ Redaction│ │  │ │ Redaction│ │  │ │ Redaction│ │     │
│  │ └──────────┘ │  │ └──────────┘ │  │ └──────────┘ │     │
│  │ ┌──────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │     │
│  │ │Local Cache│ │  │ │Local Cache│ │  │ │Local Cache│ │     │
│  │ └──────────┘ │  │ └──────────┘ │  │ └──────────┘ │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ Cache Operations
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              DISTRIBUTED CACHE PLANE                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  Hazelcast   │  │  Hazelcast   │  │  Hazelcast   │     │
│  │   Node 1     │  │   Node 2     │  │   Node N     │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ API Traffic & Logs
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              SUPPORTING SERVICES                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   MongoDB    │  │ Elasticsearch │  │  Log          │     │
│  │              │  │  (1. Tercih)  │  │  Connectors   │     │
│  │              │  │              │  │  (Kafka, DB,   │     │
│  │              │  │              │  │   Syslog, etc)│     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ Backend API Requests
                            ▼
                    ┌─────────────────────────────────────┐
                    │      BACKEND APIs                   │
                    │  (REST, SOAP, GraphQL, etc.)       │
                    └─────────────────────────────────────┘
```

### Dağıtılmış Önbellek (Distributed Cache)

Apinizer, dağıtılmış önbellekte saklayarak hem bileşenlerinin paylaştığı verileri yönetir, hem de performans iyileştirmesi sağlar.

<CardGroup cols={2}>
  <Card title="Dağıtılmış Önbellek (Distributed Cache)" icon="layer-group">
    Apinizer distributed cache gerçekleştirimi olarak, Kubernetes üzerinde kolayca genişletilerek ölçeklenebilen, dinamik konfigürasyon ile yönetilebilen ve başarılı performans gösteren Hazelcast teknolojisini kullanmaktadır. Distributed Cache üzerinde Quota, Throttling, OAuth2 Token, Yük Dengeleme Nesnesi.. vb nesneler tutulmakta ve işlenmektedir.
  </Card>
  <Card title="Cache API" icon="code">
    Cache üzerinden yapılacak olan tüm işlemler için Cache API kullanılır.
  </Card>
</CardGroup>

## 2. Dağıtım Esnekliği ve Çalışma Ortamları

Apinizer platformu, farklı altyapı ortamlarında esnek bir şekilde çalışabilir. Bu esneklik, kurumların mevcut IT altyapılarına kolayca entegre edilmesini sağlar.

### Platform Bağımsızlığı

Apinizer temelde **Java tabanlı** bir platformdur ve bu sayede Linux/Windows gibi farklı işletim sistemlerinde çalışabilir. Kubernetes üzerinden çalıştığından, Kubernetes kurulu olan bütün işletim sistemlerini desteklemektedir.

**Desteklenen İşletim Sistemleri:**
* Linux (Ubuntu Server, RHEL, CentOS)
* Windows Server
* Kubernetes destekleyen tüm platformlar

### Sanal Ortam Uyumluluğu (VM)

Klasik sanal makine (VMware, Hyper-V, KVM) ortamlarında kolaylıkla kurulabilir ve çalıştırılabilir.

**VM Ortamları:**
* VMware vSphere
* Microsoft Hyper-V
* KVM (Kernel-based Virtual Machine)
* Diğer hipervizör platformları

### Konteyner Desteği (Docker)

Kubernetes kullanmadan da tekil Docker ortamında veya Docker Compose ile hızlıca devreye alınabileceği.

**Docker Desteği:**
* Standalone Docker container'ları
* Docker Compose ile çoklu container yönetimi
* Docker Swarm ile küme yönetimi

### Bulut Yerel (Cloud-Native) Platformlar

Kubernetes, OpenShift, Tanzu gibi sektör lideri konteyner orkestrasyon platformlarında tam destek verdiği ve ölçeklenebildiği. Bu, esnekliğinizi gösterir.

**Desteklenen Platformlar:**
* **Kubernetes**: Standart Kubernetes cluster'ları
* **OpenShift**: Red Hat OpenShift Origin 3.11 ve üzeri
* **VMware Tanzu**: Tanzu Kubernetes Grid
* **Amazon EKS**: Elastic Kubernetes Service
* **Microsoft AKS**: Azure Kubernetes Service
* **Google GKE**: Google Kubernetes Engine
* **RKE2**: Rancher Kubernetes Engine 2

<Info>
  **Not:** Apinizer imajları DockerHub üzerinden rootless sağlandığından, herhangi bir container orchestration tabanlı platformda çalıştırılabilir.
</Info>

### DMZ ve LAN Ayrımı

Apinizer platformu, güvenlik mimarisine uygun olarak DMZ (Demilitarized Zone) ve LAN (Local Area Network) bölgelerinde farklı bileşenlerin çalışmasını destekler:

**DMZ Bölgesi:**
* **Worker Modülleri**: İstemci isteklerini karşılayan Proxy Handler'lar
* **Load Balancer**: Trafik dağıtımı ve yük dengeleme

**LAN Bölgesi:**
* **Manager Modülü**: Konfigürasyon ve yönetim
* **MongoDB**: Veri tabanı
* **Elasticsearch**: Log ve analitik veriler
* **Cache Modülü**: Dağıtılmış önbellek

Bu mimari, güvenlik duvarları ve ağ segmentasyonu ile uyumlu çalışarak, hassas bileşenlerin korunmasını sağlar.

## 3. Ölçeklenebilirlik ve Yüksek Erişilebilirlik (HA)

API Gateway'in kesintisiz çalışma ve performans gereksinimlerini nasıl karşıladığına değinilmelidir.

### Yatay Ölçekleme

Hem API Gateway hem de API Manager bileşenlerinin ihtiyaca göre yatay olarak ölçeklenebildiği.

**Worker Ölçeklendirme:**
* Trafik artışına göre Worker sayısı artırılabilir
* Kubernetes Horizontal Pod Autoscaler (HPA) ile otomatik ölçeklendirme
* Her ortamda birden fazla Worker ile yüksek erişilebilirlik

**Cache Ölçeklendirme:**
* Hazelcast cluster'ına yeni node'lar eklenebilir
* Dinamik cluster genişletme
* Otomatik veri dağıtımı ve replikasyonu

**Database Ölçeklendirme:**
* MongoDB replica set ile okuma performansı artırılabilir
* Sharding ile yatay ölçeklendirme
* Elasticsearch cluster genişletme

### Gateway Bağımsızlığı

Veri düzleminin (Gateway), Yönetim Düzleminden (Manager) bağımsız olarak, yüksek trafik için kolayca çoğaltılabileceği.

**Bağımsız Ölçeklendirme:**
* Manager modülü tek instance olarak çalışabilir
* Worker modülleri trafik gereksinimine göre bağımsız ölçeklenebilir
* Her Worker kendi Local Cache'ine sahiptir
* Manager'dan bağımsız olarak çalışabilir

### Yüksek Erişilebilirlik (HA)

Kubernetes Yüksek Erişilebilirlik Kümesi (HA Cluster) üzerinde çalıştırılarak kesintisiz hizmet sunma yeteneği.

**HA Özellikleri:**
* **Manager Redundancy**: Manager modülü için yedekleme stratejileri
* **Worker Redundancy**: Her ortamda birden fazla Worker ile yüksek erişilebilirlik
* **Database Replication**: MongoDB replica set ile veri güvenliği
* **Cache Replication**: Hazelcast'in built-in replication özellikleri
* **Automatic Failover**: Otomatik yedekleme ve geçiş mekanizmaları

**Kubernetes HA Cluster:**
* En az 3 Master Node ile yüksek erişilebilirlik
* Load Balancer VIP erişimi
* Pod anti-affinity kuralları ile dağıtım
* Health check ve readiness probe'ları

## 4. Entegrasyon Mimarisi

Apinizer'ın mevcut IT altyapısıyla nasıl konuştuğuna dair kısa bir bölüm eklenmelidir.

### Veritabanı Desteği

MongoDB, PostgreSQL gibi popüler veritabanlarını desteklediği.

**MongoDB:**
* Konfigürasyon ve metadata saklama
* Replica Set desteği
* Sharding desteği
* OAuth2 token saklama

**PostgreSQL:**
* Alternatif veritabanı desteği
* İlişkisel veri yapıları için uygun
* Transaction desteği

**Elasticsearch (1. Tercih):**
* API Manager içinde veri görselleştirme ve analiz yapılabilmesi nedeniyle birinci tercih
* Log ve analitik veri saklama
* Zaman serisi verileri için optimize
* Index lifecycle management
* Hot-Warm-Cold tier stratejisi

**Log Connectorler:**
* Database, Kafka, RabbitMQ, ActiveMQ, Syslog, Webhook, Graylog gibi farklı hedeflere log gönderimi
* Ortam bazında birden fazla connector ile eşzamanlı loglama
* Failover mekanizması ile log kaybının önlenmesi

### Harici Sistem Bağlantıları

Dış sistemlerle (LDAP, OAuth Sağlayıcılar, Harici Log Sistemleri) entegrasyon yeteneği.

**Kimlik Doğrulama Entegrasyonları:**
* **LDAP/Active Directory**: Kullanıcı kimlik doğrulama
* **OAuth2 Sağlayıcılar**: Google, Microsoft, Okta vb.
* **SAML**: Single Sign-On desteği
* **JWT**: Token tabanlı kimlik doğrulama

**Log ve Monitoring Entegrasyonları:**
* **Elasticsearch**: Merkezi log yönetimi ve API Manager içinde görselleştirme (1. tercih)
* **Database Connector**: Veritabanı sistemlerine log gönderimi
* **Kafka**: Yüksek hacimli log akışı
* **RabbitMQ/ActiveMQ**: Mesaj kuyruğu yönetimi
* **Syslog**: Syslog protokolü ile log gönderimi
* **Webhook**: Olay tabanlı bildirimler
* **Graylog**: Graylog entegrasyonu
* **Prometheus**: Metrik toplama
* **Grafana**: Görselleştirme ve dashboard'lar

**Mesajlaşma Entegrasyonları:**
* **Kafka**: Yüksek hacimli log akışı
* **RabbitMQ**: Mesaj kuyruğu yönetimi
* **Webhook**: Olay tabanlı bildirimler

**API Integrator Konnektörleri:**
* Mail (SMTP)
* API Call (REST/SOAP)
* PagerDuty, Opsgenie
* Oracle DB, PostgreSQL, IBM DB2
* Diğer veritabanı ve servis entegrasyonları

## 5. Veri ve Log Katmanı

Apinizer Platformu'nda veri ve log katmanı, sistemin veri saklama ve loglama ihtiyaçlarını karşılar. Bu katman, API trafiği logları, analitik veriler, konfigürasyon bilgileri ve diğer sistem verilerinin saklanması ve yönetilmesinden sorumludur.

### Veri Katmanları

#### MongoDB - Konfigürasyon ve Metadata

MongoDB, Apinizer platformunun konfigürasyon verilerini ve metadata'yı saklamak için kullanılır.

<CardGroup cols={2}>
  <Card title="Konfigürasyon Verileri" icon="gear">
    * API Proxy tanımları
    * Politika konfigürasyonları
    * Ortam (Environment) ayarları
    * Kullanıcı ve rol tanımları
    * Bağlantı (Connection) bilgileri
  </Card>
  <Card title="Metadata" icon="database">
    * API Proxy versiyonları
    * Deployment geçmişi
    * Kullanıcı oturumları
    * Token kayıtları (OAuth2)
    * Audit log kayıtları
  </Card>
</CardGroup>

#### Log ve Analitik Veri Yönetimi

Apinizer platformu, API trafik log'larını ve analitik verilerini yönetmek için esnek bir log gönderim mekanizmasına sahiptir. Log verileri, connectorler vasıtasıyla farklı hedeflere gönderilebilir.

<CardGroup cols={2}>
  <Card title="Elasticsearch (1. Tercih)" icon="database">
    API Manager içinde veri görselleştirme ve analiz yapılabilmesi nedeniyle birinci tercih olarak önerilir. API trafik log'ları, performans metrikleri, hata kayıtları ve analitik verilerin saklanması ve sorgulanması için kullanılır.
  </Card>
  <Card title="Log Connectorler" icon="plug">
    Database, Kafka, RabbitMQ, ActiveMQ, Syslog, Webhook, Graylog gibi farklı hedeflere log gönderimi yapılabilir. Ortam bazında birden fazla connector ile eşzamanlı loglama desteklenir.
  </Card>
</CardGroup>

### Neden Harici Veritabanı?

#### Performans Optimizasyonu

* **Ayrı Ölçeklendirme**: Konfigürasyon ve log verileri farklı performans gereksinimlerine sahiptir
* **Özel Optimizasyonlar**: Her veritabanı kendi kullanım senaryosuna göre optimize edilebilir
* **Kaynak İzolasyonu**: Yüksek trafikli log yazma işlemleri konfigürasyon okuma/yazma işlemlerini etkilemez

#### Güvenlik ve Erişim Kontrolü

* **Ayrı Erişim Politikaları**: Log verilerine erişim daha kısıtlı tutulabilir
* **Veri Maskeleme**: Hassas verilerin log'larda maskelenmesi için özel işlemler yapılabilir
* **Compliance**: Farklı veri türleri için farklı compliance gereksinimleri karşılanabilir

#### Ölçeklenebilirlik

* **Horizontal Scaling**: Her veritabanı bağımsız olarak ölçeklendirilebilir
* **Kapasite Yönetimi**: Log verilerinin büyümesi konfigürasyon veritabanını etkilemez
* **Maliyet Optimizasyonu**: Her veritabanı için uygun kaynak tahsisi yapılabilir

### Veri Stratejisi

#### Konfigürasyon Verileri (MongoDB)

**Veri Türleri:**
* Küçük ve sık güncellenen veriler
* İlişkisel yapılar (API Proxy, Politika, Ortam)
* Transaction gereksinimleri
* Hızlı okuma/yazma erişimi

**Strateji:**
* Replica Set ile yüksek erişilebilirlik
* Düzenli yedekleme
* Index optimizasyonu
* TTL (Time To Live) politikaları ile eski verilerin temizlenmesi

#### Log ve Analitik Veriler

**Elasticsearch (1. Tercih) Stratejisi:**
* API Manager içinde veri görselleştirme ve analiz yapılabilmesi nedeniyle birinci tercih
* Büyük hacimli, zaman serisi verileri
* Append-only yazma deseni
* Sorgu ve analiz odaklı
* Index lifecycle management (ILM)
* Hot-Warm-Cold tier stratejisi
* Snapshot ve restore
* Retention politikaları
* Index rotation (günlük/haftalık)

**Log Connector Stratejisi:**
* Ortam bazında log connector tanımlama
* Birden fazla connector ile eşzamanlı loglama
* Failover mekanizması ile log kaybının önlenmesi
* Her connector için uygun retry ve error handling mekanizmaları

## Ortam (Environment)

Apinizer Platformu'nda bir Ortam (Environment), API Proxy'lerin yüklenerek erişime açıldığı, kendisine ait bir erişim adresi ve ayarları olan, diğer Ortam'lardan yalıtılmış olarak ve kendisine ayrılmış CPU ve RAM gibi kaynakları kullanarak çalışan sanal sunucu alanlarıdır.

<Info>
  **Ortam, Kubernetes bağlamında "Namespace" ifadesine karşılık gelir.**
  
  Kubernetes kümeleri büyük miktarda bağlantısız iş yüklerini eş zamanlı olarak yönetebilir. Kubernetes, küme içindeki nesnelerin karmaşasını gidermek için Namespace adı verilen bir kavramdan faydalanır.
  
  Namespace'ler nesnelerin birbirleriyle gruplanmasına ve bu grupların bir birim olarak filtrelenip kontrol edilmesine olanak sağlar. Böylece özelleştirilmiş erişim kontrol politikalarını uygulamak ya da bir test ortamı için tüm birimleri birbirlerinden ayırmak için gruplamalar yapmak gibi amaçlarla kullanılabilir.
</Info>

### İki Nedenle Birden Çok Ortam Kullanılması Tavsiye Edilir

1. **Yaşam Döngüsü Yönetimi**: Geliştirme (Development), Test, Üretim (Production) gibi farklı amaca yönelik Ortamlar oluşturarak API yaşam döngüsünü yönetmek.
2. **Kaynak İzolasyonu**: Çok kaynak tüketen API'leri gruplandırarak izole çalışmalarını sağlamak, böylece diğer API'lerin performansının kötü etkilenmesine engel olmak.

### Ortam Bileşenleri

Apinizer Platformu ile oluşturulan tüm ortamlar Kubernetes altyapısında çalışmaktadır. Bir ortamda aşağıdaki bileşenler bulunur:

* **Worker Pod'ları**: API Proxy'lerin çalıştığı pod'lar
* **Cache Pod'ları**: Dağıtılmış önbellek pod'ları
* **Integration Pod'ları**: API Integrator görevlerinin çalıştığı pod'lar

<Warning>
  API Proxy'ler, bir veya birden fazla ortam üzerine yüklenebilir. Kurulumu yapılan ortam ya da ortamların hepsi bir küme (cluster) içinde yer alır ve Apinizer Platformu'nun kurulu olduğu sunucular üzerinde çalışır.
</Warning>

## Sonraki Adımlar

<CardGroup cols={2}>
  <Card title="Deployment Modelleri" icon="sitemap" href="/tr/apinizer-anlama/deployment/deployment-modelleri">
    Hangi deployment modelini seçeceğinizi öğrenin
  </Card>
  <Card title="Ağ Topolojisi" icon="network-wired" href="/tr/apinizer-anlama/deployment/ag-topolojisi">
    Güvenli deployment desenlerini inceleyin
  </Card>
  <Card title="Kapasite Planlama" icon="calculator" href="/tr/apinizer-anlama/sistem/kapasite-planlama">
    Kapasite planlama ve gereksinimleri öğrenin
  </Card>
  <Card title="Kapasite Planlama" icon="calculator" href="/tr/apinizer-anlama/sistem/kapasite-planlama">
    Donanım gereksinimlerini inceleyin
  </Card>
</CardGroup>
