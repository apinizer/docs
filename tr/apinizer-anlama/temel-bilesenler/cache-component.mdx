---
title: "Cache Component"
description: "Cache Component (Önbellek Bileşeni), Apinizer platformunda API Gateway performansını artırmak için önbellekleme işlevleri sağlayan bileşendir. Sık kullanılan verileri ve konfigürasyonları bellekte tutarak API Gateway'in yanıt süresini azaltır ve backend yükünü hafifletir."
---

## Cache Component Kavramı

Cache Component, sık kullanılan verileri ve konfigürasyonları bellekte tutarak API Gateway'in yanıt süresini azaltır ve backend yükünü hafifletir.

<CardGroup cols={2}>
  <Card title="Performans Artışı" icon="gauge">
    Yanıt süresini azaltır
  </Card>
  <Card title="Backend Yükü" icon="server">
    Backend yükünü hafifletir
  </Card>
  <Card title="Yüksek Erişilebilirlik" icon="heart-pulse">
    Backend hatalarına karşı koruma
  </Card>
  <Card title="Maliyet Tasarrufu" icon="dollar-sign">
    Backend kaynak kullanımını azaltır
  </Card>
</CardGroup>

## Cache Component Türleri

### Local Cache

API Gateway Worker'larında yerel olarak tutulan önbellek:

<AccordionGroup>
  <Accordion title="Konfigürasyon Cache">
    * API Proxy konfigürasyonları
    * Policy tanımları
    * Routing bilgileri
    * Metadata bilgileri
  </Accordion>
  
  <Accordion title="Token Cache">
    * OAuth2/JWT token'ları
    * Token validation sonuçları
    * User session bilgileri
  </Accordion>
  
  <Accordion title="Response Cache">
    * API response'ları
    * Cache key bazlı saklama
    * TTL (Time To Live) yönetimi
  </Accordion>
</AccordionGroup>

### Distributed Cache

Birden fazla API Gateway instance'ı arasında paylaşılan önbellek:

<CardGroup cols={2}>
  <Card title="Hazelcast" icon="network-wired">
    * Distributed cache
    * Multi-node support
    * High availability
  </Card>
  <Card title="Redis" icon="database">
    * Redis entegrasyonu
    * Pub/Sub desteği
  </Card>
  <Card title="Shared State" icon="users">
    * Paylaşılan durum
    * Session replication
  </Card>
  <Card title="Cache Invalidation" icon="arrows-rotate">
    * Otomatik invalidation
    * Event-based invalidation
  </Card>
</CardGroup>

## Cache Stratejileri

### Cache-Aside (Lazy Loading)

```
1. Cache'de ara
2. Bulunamazsa backend'den al
3. Cache'e kaydet
4. İstemciye döndür
```

### Write-Through

```
1. Backend'e yaz
2. Cache'e yaz
3. İstemciye döndür
```

### Write-Back (Write-Behind)

```
1. Cache'e yaz
2. İstemciye döndür
3. Asenkron olarak backend'e yaz
```

## Cache Yapılandırması

### Cache Key Stratejisi

Cache key'ler nasıl oluşturulur:

<CardGroup cols={2}>
  <Card title="URL Bazlı" icon="link">
    ```
    GET /api/v1/products
    Cache Key: /api/v1/products
    ```
  </Card>
  <Card title="Query Parametreli" icon="code">
    ```
    GET /api/v1/products?category=electronics
    Cache Key: /api/v1/products?category=electronics
    ```
  </Card>
  <Card title="Header Bazlı" icon="file-lines">
    ```
    Cache Key: URL + Header değerleri
    ```
  </Card>
  <Card title="Custom Key" icon="key">
    ```
    Custom cache key oluşturma
    ```
  </Card>
</CardGroup>

### Cache TTL (Time To Live)

<AccordionGroup>
  <Accordion title="Sabit TTL">
    * Belirli bir süre için cache'de tutma
    * Örnek: 5 dakika, 1 saat
  </Accordion>
  
  <Accordion title="Dinamik TTL">
    * Response header'larına göre TTL
    * Cache-Control header'ı
    * Expires header'ı
  </Accordion>
  
  <Accordion title="Conditional TTL">
    * Koşullu TTL
    * Response status code'a göre
    * Content type'a göre
  </Accordion>
</AccordionGroup>

## Cache Invalidation

Cache'in geçersiz kılınması:

<CardGroup cols={2}>
  <Card title="TTL Expiry" icon="clock">
    * Zaman aşımı ile otomatik silme
  </Card>
  <Card title="Manual Invalidation" icon="trash">
    * Manuel cache temizleme
    * API üzerinden invalidation
  </Card>
  <Card title="Event-Based" icon="bell">
    * Event bazlı invalidation
    * Webhook ile invalidation
  </Card>
  <Card title="Pattern-Based" icon="filter">
    * Pattern bazlı invalidation
    * Wildcard invalidation
  </Card>
</CardGroup>

## Cache Kullanım Senaryoları

### Senaryo 1: Response Caching

```
1. İlk istek: Backend'den al, cache'e kaydet
2. Sonraki istekler: Cache'den döndür
3. TTL sonrası: Cache'i temizle, tekrar backend'den al
```

### Senaryo 2: Token Caching

```
1. Token doğrulama: Token cache'de var mı kontrol et
2. Cache'de varsa: Doğrulama yapmadan döndür
3. Cache'de yoksa: Identity Manager'dan doğrula, cache'e kaydet
```

### Senaryo 3: Configuration Caching

```
1. API Proxy konfigürasyonu: Management API'den al
2. Local cache'e kaydet
3. Konfigürasyon değişikliğinde: Cache'i invalidate et
```

## Cache Best Practices

<CardGroup cols={2}>
  <Card title="TTL Yönetimi" icon="clock">
    * Uygun TTL değerleri seçin
    * Çok kısa TTL performansı düşürür
    * Çok uzun TTL stale data riski
  </Card>
  <Card title="Cache Key Design" icon="key">
    * Anlamlı cache key'ler
    * Collision'ları önleyin
    * Pattern-based invalidation
  </Card>
  <Card title="Memory Management" icon="memory">
    * Cache size limitleri
    * Eviction policies
    * Memory monitoring
  </Card>
  <Card title="Error Handling" icon="triangle-exclamation">
    * Cache hatalarında fallback
    * Backend'e yönlendirme
    * Error logging
  </Card>
</CardGroup>

## Sonraki Adımlar

<CardGroup cols={2}>
  <Card title="Storage Layer" icon="database" href="/tr/apinizer-anlama/temel-bilesenler/storage-layer">
    Storage Layer bileşenini öğrenin
  </Card>
  <Card title="API Gateway" icon="shield" href="/tr/apinizer-anlama/temel-bilesenler/api-gateway">
    API Gateway bileşenini öğrenin
  </Card>
  <Card title="Cache Yapılandırması" icon="gear" href="/tr/admin/cache-yapilandirma">
    Cache yapılandırması
  </Card>
  <Card title="Performance Tuning" icon="gauge" href="/tr/admin/performance-tuning">
    Performans optimizasyonu
  </Card>
</CardGroup>
