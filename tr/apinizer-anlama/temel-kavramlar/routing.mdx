---
title: "Routing"
description: 'Routing, API Proxy\'de isteklerin backend API\'lere nasıl yönlendirildiğini tanımlar. HTTP, gRPC ve WebSocket protokolleri için routing desteği sağlar.'
---

Routing (Yönlendirme), API Proxy'de istemcilerden gelen isteklerin backend API'lere nasıl yönlendirildiğini tanımlayan mekanizmadır. Routing, Client Route ve Upstream Target kavramları üzerine kuruludur.

## Routing Kavramı

Routing, bir API Proxy'de iki temel bileşenden oluşur:

<CardGroup cols={2}>
  <Card title="Client Route" icon="arrow-right" href="/tr/genel-bakis/apinizeri-anlamak/temel-kavramlar-ve-terminoloji/client-route-where-requests-enter">
    İsteklerin API Proxy'ye girdiği nokta. İstemciler bu endpoint'e istek gönderir.
  </Card>
  <Card title="Upstream Target" icon="arrow-left" href="/tr/genel-bakis/apinizeri-anlamak/temel-kavramlar-ve-terminoloji/upstream-target-where-requests-go">
    İsteklerin yönlendirildiği backend API. API Proxy bu adrese istek gönderir.
  </Card>
</CardGroup>

## Routing Akışı

```
İstemci
   │
   ▼ (HTTPS Request)
┌──────────────┐
│ Client Route │ ← İsteklerin girdiği nokta
│ /api/v1/... │
└──────┬───────┘
       │
       │ Routing Logic
       │ (Load Balancing, Failover)
       │
       ▼
┌──────────────┐
│Upstream Target│ ← İsteklerin yönlendirildiği backend
│ backend:8080 │
└──────┬───────┘
       │
       ▼
   Backend API
```

## Routing Türleri

Apinizer platformu farklı protokoller için routing desteği sağlar:

<CardGroup cols={3}>
  <Card title="HTTP Routing" icon="globe" href="#http-routing">
    HTTP/HTTPS protokolü için routing. REST API'ler için kullanılır.
  </Card>
  <Card title="gRPC Routing" icon="network-wired" href="#grpc-routing">
    gRPC protokolü için routing. Microservice mimarileri için kullanılır.
  </Card>
  <Card title="WebSocket Routing" icon="globe" href="#websocket-routing">
    WebSocket protokolü için routing. Gerçek zamanlı iletişim için kullanılır.
  </Card>
</CardGroup>

## HTTP Routing

HTTP Routing, HTTP/HTTPS protokolü kullanan REST API'ler için routing desteğidir.

### HTTP Routing Özellikleri

<CardGroup cols={2}>
  <Card title="Protokol Desteği" icon="globe">
    * HTTP/1.1
    * HTTP/2
    * HTTPS (TLS/SSL)
  </Card>
  <Card title="Method Desteği" icon="code">
    * GET, POST, PUT, DELETE
    * PATCH, HEAD, OPTIONS
    * Custom methods
  </Card>
  <Card title="Content-Type" icon="file">
    * application/json
    * application/xml
    * application/x-www-form-urlencoded
    * multipart/form-data
  </Card>
  <Card title="Özellikler" icon="star">
    * Path matching (exact, prefix, regex)
    * Query parameter handling
    * Header manipulation
    * Body transformation
    * Host bazlı routing
    * Method bazlı routing
  </Card>
</CardGroup>

### HTTP Routing Yapılandırması

```yaml
client_route:
  path: /api/v1/*
  method: GET, POST, PUT, DELETE
  protocol: https
  port: 443

upstream_target:
  url: http://backend-service:8080
  protocol: http
  health_check: /health
```

### HTTP Routing Kullanım Senaryoları

* **REST API Gateway**: REST API'lerin yönetimi
* **API Versioning**: API versiyonlama
* **Legacy System Integration**: Eski sistemlerle entegrasyon
* **Public API Exposure**: Dış dünyaya API açma

Detaylı bilgi için [HTTP Routing](/tr/gelistirici/gelistirici-kilavuzu/routing-configuration/http-routing) sayfasına bakın.

## gRPC Routing

gRPC Routing, gRPC protokolü kullanan microservice'ler için routing desteğidir.

### gRPC Routing Özellikleri

<CardGroup cols={2}>
  <Card title="Protokol Desteği" icon="network-wired">
    * gRPC (HTTP/2 üzerinde)
    * gRPC-Web
    * TLS/SSL desteği
  </Card>
  <Card title="Service Discovery" icon="magnifying-glass">
    * Protocol Buffers (Protobuf)
    * Service definition
    * Method routing
  </Card>
  <Card title="Özellikler" icon="star">
    * Unary calls
    * Server streaming
    * Client streaming
    * Bidirectional streaming
  </Card>
  <Card title="Load Balancing" icon="scale-balanced">
    * gRPC-aware load balancing
    * Health checking
    * Failover
  </Card>
</CardGroup>

### gRPC Routing Yapılandırması

```yaml
client_route:
  path: /com.example.ProductService/*
  protocol: grpc
  port: 50051

upstream_target:
  url: grpc://backend-service:50051
  protocol: grpc
  service: com.example.ProductService
```

### gRPC Routing Kullanım Senaryoları

* **Microservice Communication**: Microservice'ler arası iletişim
* **High Performance APIs**: Yüksek performans gereksinimleri
* **Streaming APIs**: Gerçek zamanlı veri akışı
* **Internal APIs**: İç sistem API'leri

Detaylı bilgi için [gRPC Routing](/tr/gelistirici/gelistirici-kilavuzu/routing-configuration/grpc-routing) sayfasına bakın.

## WebSocket Routing

WebSocket Routing, WebSocket protokolü kullanan gerçek zamanlı uygulamalar için routing desteğidir.

### WebSocket Routing Özellikleri

<CardGroup cols={2}>
  <Card title="Protokol Desteği" icon="globe">
    * WebSocket (ws://)
    * Secure WebSocket (wss://)
    * HTTP Upgrade
  </Card>
  <Card title="Bağlantı Yönetimi" icon="plug">
    * Connection establishment
    * Connection persistence
    * Connection pooling
  </Card>
  <Card title="Mesaj İşleme" icon="message">
    * Text messages
    * Binary messages
    * Message routing
  </Card>
  <Card title="Özellikler" icon="star">
    * Subprotocol support
    * Ping/Pong frames
    * Connection timeout
  </Card>
</CardGroup>

### WebSocket Routing Yapılandırması

```yaml
client_route:
  path: /ws/*
  protocol: wss
  port: 443

upstream_target:
  url: ws://backend-service:8080
  protocol: ws
  subprotocol: chat
```

### WebSocket Routing Kullanım Senaryoları

* **Real-time Chat**: Gerçek zamanlı sohbet uygulamaları
* **Live Updates**: Canlı güncellemeler
* **Gaming**: Oyun uygulamaları
* **IoT**: IoT cihazları ile iletişim

Detaylı bilgi için [WebSocket Routing](/tr/gelistirici/gelistirici-kilavuzu/routing-configuration/websocket-routing) sayfasına bakın.

## Protokol Karşılaştırması

| Özellik | HTTP | gRPC | WebSocket |
|---------|------|------|------------|
| **Protokol** | HTTP/1.1, HTTP/2 | HTTP/2 | WebSocket |
| **Veri Formatı** | JSON, XML | Protobuf | Text, Binary |
| **İletişim** | Request-Response | Request-Response, Streaming | Bidirectional |
| **Performans** | Orta | Yüksek | Yüksek (persistent) |
| **Kullanım** | REST API'ler | Microservices | Real-time apps |
| **Browser Desteği** | ✅ | ⚠️ (gRPC-Web) | ✅ |

## Protokol Seçim Kılavuzu

<AccordionGroup>
  <Accordion title="Ne Zaman HTTP Kullanılmalı?">
    * REST API'ler için
    * Browser tabanlı uygulamalar için
    * Geniş uyumluluk gereksinimleri için
    * JSON/XML veri formatları için
  </Accordion>
  
  <Accordion title="Ne Zaman gRPC Kullanılmalı?">
    * Microservice mimarileri için
    * Yüksek performans gereksinimleri için
    * Streaming gereksinimleri için
    * İç sistem API'leri için
  </Accordion>
  
  <Accordion title="Ne Zaman WebSocket Kullanılmalı?">
    * Gerçek zamanlı iletişim için
    * Canlı güncellemeler için
    * Bidirectional iletişim için
    * Düşük latency gereksinimleri için
  </Accordion>
</AccordionGroup>

## Load Balancing Strategies

Backend'de birden fazla instance varsa, yük dengeleme stratejileri kullanılır:

<CardGroup cols={2}>
  <Card title="Round Robin" icon="rotate">
    İstekler sırayla tüm backend instance'larına dağıtılır.
  </Card>
  <Card title="Least Connections" icon="users">
    En az bağlantıya sahip backend'e istek gönderilir.
  </Card>
  <Card title="IP Hash" icon="hashtag">
    İstemci IP'sine göre backend seçilir. Aynı IP her zaman aynı backend'e gider.
  </Card>
  <Card title="Weighted Round Robin" icon="scale-balanced">
    Backend'lere ağırlık atanır ve buna göre istek dağıtılır.
  </Card>
</CardGroup>

Detaylı bilgi için [Load Balancing Strategies](/tr/genel-bakis/apinizeri-anlamak/temel-kavramlar-ve-terminoloji/load-balancing-strategies) sayfasına bakın.

## Routing Yapılandırması

### Client Route Yapılandırması

Client Route, istemcilerden gelen isteklerin karşılandığı endpoint'i tanımlar:

* **Path**: `/api/v1/products`
* **Method**: GET, POST, PUT, DELETE, vb.
* **Protocol**: HTTP, HTTPS
* **Port**: 443, 80, vb.

### Upstream Target Yapılandırması

Upstream Target, backend API'nin adresini tanımlar:

* **URL**: `http://backend-service:8080`
* **Protocol**: HTTP, HTTPS, gRPC, WebSocket
* **Health Check**: Backend sağlık kontrolü
* **Timeout**: İstek zaman aşımı

## Routing Özellikleri

### Dinamik Yönlendirme

Apinizer'ın Client Route özelliği sayesinde dinamik yönlendirme yapılabilir:

<CardGroup cols={2}>
  <Card title="Host Bazlı Routing" icon="globe">
    Host header değerine göre farklı proxy'lere yönlendirme:
    ```
    Host: api.example.com → Proxy A
    Host: test.example.com → Proxy B
    ```
  </Card>
  <Card title="Header Bazlı Routing" icon="file-lines">
    HTTP header değerlerine göre yönlendirme:
    ```
    X-Environment: production → Proxy A
    X-Environment: test → Proxy B
    ```
  </Card>
  <Card title="Method Bazlı Routing" icon="code">
    HTTP method'a göre yönlendirme:
    ```
    GET /api/products → Proxy A
    POST /api/products → Proxy B
    ```
  </Card>
  <Card title="Kombinasyon Bazlı Routing" icon="puzzle-piece">
    Host, header ve method kombinasyonlarına göre yönlendirme
  </Card>
</CardGroup>

### Yönlendirme Öncelik Sırası

Gateway, gelen istekleri aşağıdaki öncelik sırasına göre değerlendirir:

1. **Relative Path** (En yüksek öncelik)
2. **Hosts**
3. **Headers**
4. **Methods** (En düşük öncelik)

<Info>
  **Eşleştirme Mantığı:**
  * **Hosts**: Birden fazla host tanımlandığında **OR** mantığı ile çalışır (herhangi biri eşleşirse yeterli)
  * **Headers**: Birden fazla header tanımlandığında **AND** mantığı ile çalışır (tümü eşleşmeli)
</Info>

<AccordionGroup>
  <Accordion title="Path Matching">
    * Exact match: Tam eşleşme
    * Prefix match: Önek eşleşmesi (daha spesifik path'ler önceliklidir)
    * Regex match: Düzenli ifade eşleşmesi
    
    **Path Önceliği:**
    ```
    /api/v1/products/{id} → Daha spesifik (öncelikli)
    /api/v1/products      → Daha genel
    ```
  </Accordion>
  
  <Accordion title="Method Matching">
    * HTTP method kontrolü (GET, POST, PUT, DELETE)
    * Method bazlı routing
    * Method override desteği
    * Method tanımlanmazsa tüm method'lar kabul edilir
  </Accordion>
  
  <Accordion title="Header Matching">
    * Header bazlı routing
    * Content-Type bazlı routing
    * Custom header bazlı routing
    * **AND mantığı**: Tüm header'lar eşleşmeli
  </Accordion>
  
  <Accordion title="Host Matching">
    * Host header bazlı routing
    * Wildcard hostname desteği (*.example.com, example.*)
    * **OR mantığı**: Herhangi bir host eşleşirse yeterli
  </Accordion>
  
  <Accordion title="Query Parameter Matching">
    * Query parametresi bazlı routing
    * Parametre değeri bazlı routing
  </Accordion>
</AccordionGroup>

## Failover ve Retry

### Failover

Backend instance'larından biri hata verdiğinde:

* **Automatic Failover**: Otomatik olarak başka bir instance'a geçiş
* **Health Check**: Düzenli sağlık kontrolü
* **Circuit Breaker**: Hata durumunda geçici olarak devre dışı bırakma

### Retry

Geçici hatalar için retry mekanizması:

* **Retry Count**: Tekrar deneme sayısı
* **Retry Delay**: Tekrar deneme aralığı
* **Retry Conditions**: Hangi hatalar için retry yapılacağı

## Sonraki Adımlar

<CardGroup cols={2}>
  <Card title="Client Route" icon="arrow-right" href="/tr/genel-bakis/apinizeri-anlamak/temel-kavramlar-ve-terminoloji/client-route-where-requests-enter">
    Client Route kavramını öğrenin
  </Card>
  <Card title="Upstream Target" icon="arrow-left" href="/tr/genel-bakis/apinizeri-anlamak/temel-kavramlar-ve-terminoloji/upstream-target-where-requests-go">
    Upstream Target kavramını öğrenin
  </Card>
  <Card title="HTTP Routing" icon="globe" href="/tr/gelistirici/gelistirici-kilavuzu/routing-configuration/http-routing">
    HTTP Routing yapılandırması
  </Card>
  <Card title="Load Balancing" icon="scale-balanced" href="/tr/genel-bakis/apinizeri-anlamak/temel-kavramlar-ve-terminoloji/load-balancing-strategies">
    Load balancing stratejileri
  </Card>
</CardGroup>
