---
title: "Mesaj Oluşturucu"
description: "Template ve form tabanlı mesaj oluşturma ile değişken değerlerini hedef değişkenlere atayabilirsiniz. Koşullu satır yürütme, JEXL expression desteği ve hata yönetimi işlemlerini gerçekleştirebilirsiniz"
---

<Tip>
Bu doküman spesifik bir politikanın detaylı kullanımını anlatır. Eğer Apinizer politika yapısını ilk kez kullanıyorsanız veya politikaların genel çalışma prensiplerini öğrenmek istiyorsanız, öncelikle [Politika Nedir?](/tr/concepts/temel-kavramlar/politika-nedir) sayfasını okumanızı öneririz.
</Tip>

## Genel Bakış

### Amacı Nedir?

- Template ve form tabanlı mesaj oluşturarak değişken değerlerini hedef değişkenlere atamak.
- İstek veya yanıttaki body, header, query parametresi gibi kaynaklardan veri okuyup yeni değişkenler oluşturmak.
- JEXL expression'ları ile dinamik içerik üretmek ve birden fazla kaynaktan veri birleştirmek.
- Satır bazlı koşullu çalıştırma ile sadece belirli durumlarda değişken ataması yapmak.

### Çalışma Prensibi

1. **İstek Gelişi**: API Gateway'e gelen HTTP/HTTPS isteği için MessageContext oluşturulur.
2. **Politika Kontrolü**: Mesaj Oluşturucu politikası aktif ise, sistem aşağıdaki sırayla kontrol yapar:
   - Condition (koşul) tanımlı mı? Varsa koşul sağlanıyor mu?
   - Politika aktif mi (active=true)?
3. **Satır Zinciri Çalıştırma**: Satır listesi (Row List) sırasıyla değerlendirilir. Her satır için:
   - Satır koşulu kontrol edilir (varsa).
   - **Form** modunda: Kaynak değişkenden değer okunur.
   - **Template** modunda: Şablon `#{variable}` syntax'ı ile işlenir, JEXL expression'lar evaluate edilir.
   - Sonuç hedef değişkene yazılır.
4. **Boş Değer İşleme**:
   - Değer boş ve `Zorunlu=true` ise hata fırlatılır.
   - Değer boş ise varsayılan değer kullanılır.
5. **Hata İşleme**: `Hata Durumunda Devam Et` aktifse satır atlanır ve sonraki satıra geçilir. Pasifse politika hata ile sonlanır.

## Özellikler ve Yetenekler

### Temel Özellikler

- **İki Oluşturma Modu**: Form modu (basit değişken kopyalama) ve Template modu (JEXL expression desteği ile dinamik içerik oluşturma).
- **Satır Bazlı İşleme**: Her satır bağımsız olarak yapılandırılabilir; kaynak, hedef, koşul, varsayılan değer ayrı ayrı belirlenir.
- **Sürükle-Bırak Sıralama**: Satır sırası sürükle-bırak ile kolayca değiştirilebilir.
- **Aktif/Pasif Durum Kontrolü**: Politikanın aktif veya pasif durumunu kolayca değiştirme. Pasif durumda politika uygulanmaz ancak yapılandırması saklanır.
- **Koşul Bazlı Uygulama**: Query Builder ile hem politika seviyesinde hem satır seviyesinde koşullar tanımlanabilir.

### İleri Düzey Özellikler

- **JEXL Expression Desteği**: Template modunda `#{expression}` syntax'ı ile matematiksel, mantıksal ve string operatörleri kullanılabilir.
- **Çoklu Değişken Kaynağı**: Body (JSON/XML path), Header, Query/Path/Form parametreleri ve Context Variable'lardan veri okunabilir.
- **Satır Seviyesi Hata Yönetimi**: Her satır için `Hata Durumunda Devam Et` ve `Zorunlu` bayrakları ayrı ayrı ayarlanabilir.
- **Export/Import Özelliği**: Politika yapılandırmasını ZIP dosyası olarak export etme. Farklı ortamlara (Development, Test, Production) import etme. Versiyon kontrolü ve yedekleme imkanı.
- **Policy Group ve Proxy Group Desteği**: Birden fazla politikayı Policy Group içinde yönetme. Proxy Group'lara toplu politika atama. Merkezi güncelleme ve deploy işlemleri.
- **Deploy ve Versiyonlama**: Politika değişikliklerini canlı ortama deploy etme. Hangi API Proxy'lerde kullanıldığını görme (Policy Usage). Proxy Group ve Policy Group kullanım raporları.

## Kullanım Senaryoları

| Senaryo | Durum | Çözüm (Politika Uygulaması) | Beklenen Davranış / Sonuç |
|---------|-------|----------------------------|---------------------------|
| Dinamik Header Oluşturma | Farklı kaynaklardan alınan bilgilerle özel header oluşturulacak. | Template modu: `User: #{body.$.userName}, Time: #{dateTime.formattedText}` → hedef: `X-Custom-Header`. | Header her istekte güncel kullanıcı adı ve zaman bilgisiyle doldurulur. |
| Değişken Kopyalama | İstek body'sindeki bir alan, başka bir değişkene atanacak. | Form modu: Kaynak=`body.$.userId` → Hedef=`customUserId`. | userId değeri customUserId değişkenine kopyalanır, sonraki politikalarda kullanılabilir. |
| Koşullu Zenginleştirme | Sadece POST isteklerinde body'den veri çıkarılacak. | Satır koşulu: `request.method = POST`. Template modu ile body'den veri çıkarma. | GET isteklerinde satır atlanır, POST'ta veri çıkarılır. |
| Varsayılan Değer Atama | Header'da eksik olan bir değer için fallback sağlanacak. | Form modu: Kaynak=`header.X-Tenant-Id`, Varsayılan Değer=`default-tenant`, Zorunlu=Hayır. | Header varsa değeri kullanılır, yoksa `default-tenant` atanır. |
| Çoklu Kaynak Birleştirme | Farklı kaynaklardan alınan bilgiler tek bir değişkende birleştirilecek. | Template modu: `#{header.X-User-Id}-#{dateTime.timestamp}-#{apiProxy.name}`. | Birleşik değer hedef değişkene yazılır. |
| Zorunlu Alan Doğrulama | Belirli bir değişkenin boş olmaması garanti edilecek. | Form modu: Kaynak=`body.$.orderId`, Zorunlu=Evet, Hata Durumunda Devam Et=Hayır. | orderId boşsa politika hata fırlatır ve akış durur. |

## Politika Parametrelerini Yapılandırma

Bu bölümde yeni bir **Mesaj Oluşturucu** politikası oluşturabilir ya da mevcut politika parametrelerini yapılandırarak mesaj oluşturma kurallarını belirleyebilirsiniz.

### Yeni Mesaj Oluşturucu Politikası Oluşturma

#### Yapılandırma Adımları

| Adım | Açıklama / İşlem |
|------|------------------|
| **Adım 1: Oluşturma Sayfasına Gitme** | - Sol menüden **Development → Global Settings → Global Policies → Message Builder** bölümüne gidin.<br />- Sağ üstteki **[+ Create]** butonuna tıklayın. |
| **Adım 2: Temel Bilgileri Girme** | **Policy Status (Politika Durumu):** Aktif/Pasif durumu gösterir. Yeni politikalar varsayılan olarak aktiftir.<br /><br />**Name (İsim) Zorunlu:**<br />Örnek: `Request_Enrichment_Builder`<br />- Benzersiz isim girin, boşlukla başlamaz.<br />- Sistem otomatik kontrol eder: Yeşil tik: kullanılabilir, Kırmızı çarpı: mevcut isim.<br /><br />**Description (Açıklama):**<br />Örnek: "İstek body'sindeki kullanıcı bilgilerini çıkararak header'lara ekler."<br />- Maks. 1000 karakter.<br />- Politikanın amacını açıklayın. |
| **Adım 3: Satır Ekleme** | - **Satır ekle** butonuna tıklayın.<br />- Açılan menüden oluşturma modunu seçin:<br />  - **Form**: Basit değişken kopyalama.<br />  - **Template**: JEXL expression desteği ile şablon tabanlı oluşturma.<br />- Yeni satır listeye eklenir. |
| **Adım 4: Satır Düzenleme** | - Satır üzerindeki menüden **Düzenle** seçin veya satıra çift tıklayın.<br />- Açılan diyalogda aşağıdaki alanları yapılandırın:<br /><br />**Oluşturma Modu (Build Mode):** Form veya Template seçin.<br /><br />**Kaynak Değişken (Source Variable)** *(Form modu):*<br />Değişken seçim diyaloğundan kaynak değişkeni seçin (body, header, query param vb.).<br /><br />**Şablon (Template)** *(Template modu):*<br />Code editor'da `#{variable}` syntax'ı ile şablon yazın.<br />JEXL expression'lar desteklenir.<br /><br />**Hedef Değişken (Target Variable) Zorunlu:**<br />Sonucun yazılacağı değişkeni seçin.<br /><br />**Varsayılan Değer (Default Value):**<br />Kaynak boş olduğunda kullanılacak değer.<br /><br />**Zorunlu (Required):**<br />İşaretlenirse, kaynak değer boş olduğunda hata fırlatılır. Varsayılan: Hayır.<br /><br />**Hata Durumunda Devam Et (Continue on Error):**<br />İşaretlenirse, satırda hata oluştuğunda sonraki satıra geçilir. Varsayılan: Evet. |
| **Adım 5: Satır Koşulu Tanımlama (İsteğe Bağlı)** | - Satır düzenleme diyaloğundaki **Koşul** bölümünden Query Builder ile satır seviyesinde koşul tanımlayabilirsiniz.<br />- Koşul sağlanmadığında satır atlanır. |
| **Adım 6: Satır Sıralama** | - Satırları sürükle-bırak ile yeniden sıralayabilirsiniz.<br />- Satırlar listede göründükleri sırayla çalıştırılır. |
| **Adım 7: Koşul Tanımlama (İsteğe Bağlı)** | - **Condition** sekmesine geçin.<br />- Politika seviyesinde koşul tanımlayarak politikanın hangi durumda aktif olacağını belirleyin.<br /><br />Detaylar için: [Koşullar (Conditions)](/tr/concepts/temel-kavramlar/politika-nedir#koşullar) |
| **Adım 8: Hata Mesajı Özelleştirme (İsteğe Bağlı)** | - **Error Message Customization** sekmesine gidin.<br />- Politika hata fırlatığında dönecek mesajı özelleştirin.<br />- `#{error.effectiveErrorCode}`, `#{message.correlationId}` gibi yer tutucular kullanılabilir.<br /><br />Detay için: [Şablon Tabanlı Hata Mesajları](/tr/concepts/temel-kavramlar/politika-nedir#şablon-tabanlı-dinamik-hata-mesajları) |
| **Adım 9: Kaydetme** | - Sağ üstteki **[Save]** butonuna tıklayın.<br /><br />**Kontrol Listesi:**<br />- Benzersiz isim<br />- En az bir satır mevcut<br />- Her satırda hedef değişken seçili<br />- Form modunda kaynak değişken seçili<br />- Template modunda şablon dolu<br /><br />**Sonuç:**<br />- Politika listeye eklenir.<br />- API'lere bağlanabilir.<br />- Global politikaysa otomatik uygulanır. |

**Koşullar** ve **Hata Mesajı Özelleştirme** panellerinin açıklaması için [Politika Nedir?](/tr/concepts/temel-kavramlar/politika-nedir) sayfasındaki [Koşullar](/tr/concepts/temel-kavramlar/politika-nedir#koşullar) ve [Hata Mesajı Özelleştirme (Error Message Customization)](/tr/concepts/temel-kavramlar/politika-nedir#hata-mesajı-özelleştirme-error-message-customization) bölümlerini inceleyebilirsiniz.

### Satır Parametreleri

| Parametre | Açıklama | Zorunlu | Varsayılan |
|-----------|----------|---------|------------|
| **Oluşturma Modu (Build Mode)** | `Form`: Kaynak değişkenden hedef değişkene basit kopyalama.<br />`Template`: JEXL expression desteği ile şablon tabanlı oluşturma. | Evet | — |
| **Kaynak Değişken (Source Variable)** | Form modunda değerin okunacağı kaynak değişken. Body, header, query param, vb. | Form modunda evet | — |
| **Şablon (Template)** | Template modunda `#{variable}` syntax'ı ile yazılan şablon string'i. | Template modunda evet | — |
| **Hedef Değişken (Target Variable)** | Sonucun yazılacağı hedef değişken. | Evet | — |
| **Varsayılan Değer (Default Value)** | Kaynak boş olduğunda kullanılacak değer. | Hayır | — |
| **Zorunlu (Required)** | true ise kaynak boş olduğunda hata fırlatılır. | Hayır | `false` |
| **Hata Durumunda Devam Et (Continue on Error)** | true ise satırda hata oluştuğunda sonraki satıra geçilir. | Hayır | `true` |
| **Koşul (Condition)** | Satır seviyesinde koşul. Sağlanmazsa satır atlanır. | Hayır | — |

### Template Syntax

Template modunda `#{...}` syntax'ı ile değişkenlere ve JEXL expression'lara erişilir:

**Basit Değişken Erişimi:**
```
#{body.$.userName}          → JSON body'den userName alanı
#{body.$[0].name}           → JSON array body'den ilk elemanın name alanı
#{body.#/root/name}         → XML body'den XPath ile değer
#{header.Authorization}     → Authorization header değeri
#{query.page}               → Query parametresi
#{form.username}            → Form parametresi
#{path.id}                  → Path parametresi
#{credential.clientId}      → Credential bilgisi
#{request.remoteAddress}    → İstemci IP adresi
#{dateTime.formattedText}   → Formatlanmış tarih/saat
```

**Bağlam Değişkenleri (Context Variables):**

| Söz Dizimi | Açıklama |
|------------|----------|
| `#{context.request.httpMethod}` | HTTP metodu (GET, POST, vb.) |
| `#{context.request.remoteAddress}` | İstemci IP adresi |
| `#{context.response.statusCode}` | Yanıt durum kodu |
| `#{context.message.correlationId}` | Correlation ID |
| `#{context.apiProxy.name}` | API Proxy adı |
| `#{context.apiProxy.id}` | API Proxy kimliği |
| `#{context.apiMethod.name}` | API Metot adı |
| `#{context.apiMethod.httpMethod}` | API Metot HTTP metodu |
| `#{context.system.year}` | Mevcut yıl (tam sayı) |
| `#{context.system.dateTime}` | Tarih-saat (yyyy-MM-dd'T'HH:mm:ss.SSS'Z') |
| `#{context.credential.username}` | Kimlik doğrulanmış kullanıcı adı |
| `#{context.credential.email}` | Kimlik doğrulanmış kullanıcı e-posta |
| `#{context.environment.name}` | Ortam adı |
| `#{context.environment.id}` | Ortam kimliği |

**JEXL Expression (Tek Satır):**
```
#{body.$.price * 1.18}                       → Fiyata KDV ekleme
#{body.$.firstName + ' ' + body.$.lastName}  → Ad ve soyad birleştirme
#{body.$.age >= 18 ? 'adult' : 'minor'}      → Koşullu değer
#{context.request.httpMethod == 'POST' ? 'create' : 'read'}  → HTTP metoduna göre işlem tipi
#{body.$.status == 'available' ? '{"label":"Satın Alınabilir"}' : 'null'}  → JSON string üretimi
```

**JEXL Script (Çok Satır, Döngü):**

`#{...}` bloğu içinde `for`, `while`, `var`, `if/else` ifadeleri kullanılabilir. Body'den JSONPath ile çekilen array ve object değerleri otomatik olarak liste ve haritaya dönüştürülür; `for (item : collection)` ile gezinilebilir.

*Dizi Gezinme:*
```
#{
  var out = '[';
  var first = true;
  for (item : body.$.tags) {
    if (!first) { out = out + ','; }
    out = out + '{"id":' + item.id + ',"name":"' + item.name + '"}';
    first = false;
  }
  out + ']'
}
```

*Toplama / Sayaç:*
```
#{
  var total = 0;
  for (item : body.$.items) {
    total = total + item.price;
  }
  total
}
```

*if/else ile Koşullu Değer:*
```
#{
  var role = body.$.user.role;
  if (role == 'admin') {
    'TAM_YETKİ'
  } else if (role == 'manager') {
    'KISITLI_YETKİ'
  } else {
    'SADECE_OKUMA'
  }
}
```

<Note>
JEXL Script'te son değerlendirilen ifadenin değeri döndürülür. `return` anahtar kelimesi kullanılmaz.
</Note>

<Warning>
Bu politika yalnızca HTTP API Proxy'lerinde kullanılabilir. gRPC API Proxy'lerinde desteklenmez.
</Warning>

## Politikayı Silme

Bu politikanın silme adımları ve kullanımdayken uygulanacak işlemler için [Politika Yönetimi](/tr/develop/api-proxy-konfigurasyonu/politika-yonetimi) sayfasındaki [Akıştan Politika Kaldırma](/tr/develop/api-proxy-konfigurasyonu/politika-yonetimi#akıştan-politika-kaldırma) bölümüne bakabilirsiniz.

## Politikayı Dışa/İçe Aktarma

Bu politikanın dışa aktarma (Export) ve içe aktarma (Import) adımları için [Export/Import](/tr/admin/secrets-management/export-import) sayfasına bakabilirsiniz.

## Politikayı API'ye Bağlama

Bu politikanın API'lere nasıl bağlanacağına ilişkin süreç için [Politika Yönetimi](/tr/develop/api-proxy-konfigurasyonu/politika-yonetimi) sayfasındaki [Politikayı API'ye Bağlama](/tr/develop/api-proxy-konfigurasyonu/politika-yonetimi#akisa-politika-ekleme) bölümüne bakabilirsiniz.

## İleri Düzey Özellikler

| Özellik | Açıklama ve Kullanım Adımları |
|---------|-------------------------------|
| **JEXL Expression Zinciri** | - Template modunu seçin.<br />- Şablonda `#{expression}` syntax'ı ile karmaşık ifadeler yazın.<br />- Matematiksel (`+`, `-`, `*`, `/`), mantıksal (`&&`, `\|\|`, `!`), karşılaştırma (`==`, `!=`, `<`, `>`) ve koşullu (`? :`) operatörler kullanılabilir. |
| **JEXL Script ile Döngü ve Koşul** | - Template modunda `#{...}` bloğu içine çok satırlı script yazın.<br />- `for`, `while`, `var`, `if/else` ifadeleri desteklenir.<br />- Body'den çekilen JSON array değerleri otomatik olarak listeye dönüştürülür; `for (item : body.$.liste)` ile gezinilebilir.<br />- Son değerlendirilen ifadenin değeri döndürülür; `return` kullanılmaz. |
| **Çoklu Kaynak Birleştirme** | - Template modunda birden fazla kaynak kullanın.<br />- Örnek: `ID: #{body.$.id}, Name: #{header.X-User-Name}, Time: #{context.system.dateTime}`<br />- Birleşik değer tek bir hedef değişkene yazılır. |
| **Koşullu Satır Çalıştırma** | - Satır düzenleme diyaloğunda Query Builder ile koşul tanımlayın.<br />- Örnek: Sadece `Content-Type = application/json` olan isteklerde body parse etme.<br />- Koşul sağlanmadığında satır atlanır, diğer satırlar çalışmaya devam eder. |
| **Ara Değişken Zinciri** | - Bir satırda oluşturulan özel değişkeni sonraki satırların şablonunda kullanın.<br />- Örnek: İlk satırda `petName` değişkenine değer atayın, sonraki satırlarda `#{petName}` ile kullanın.<br />- Bu pattern, karmaşık JSON çıktılarını aşamalı olarak oluşturmayı sağlar. |

## Best Practices

### Yapılması Gerekenler ve En İyi Uygulamalar

| Kategori | Açıklama / Öneriler |
|----------|---------------------|
| **Satır Sıralaması** | **Kötü:** Bağımlı satırları rastgele sıralamak.<br />**İyi:** Bağımsız satırları önce, bağımlı satırları sonra sıralamak.<br />**En İyi:** Sık kullanılan ve hafif satırları başa alıp, ağır template işlemlerini sona bırakmak. |
| **Mod Seçimi** | **Kötü:** Basit kopyalama için Template modu kullanmak.<br />**İyi:** Basit kopyalamada Form, karmaşık oluşturmada Template kullanmak.<br />**En İyi:** Form modunu varsayılan olarak tercih edip, sadece birden fazla kaynak veya expression gerektiğinde Template'e geçmek. |
| **Hata Yönetimi** | **Kötü:** Tüm satırlarda `Hata Durumunda Devam Et=Hayır` bırakmak.<br />**İyi:** Kritik satırlarda Hayır, opsiyonel satırlarda Evet kullanmak.<br />**En İyi:** `Zorunlu` ve `Hata Durumunda Devam Et` bayraklarını satır önemine göre ayrı ayrı yapılandırmak. |
| **Varsayılan Değerler** | **Kötü:** Varsayılan değer tanımlamadan zorunlu olmayan satırlar bırakmak.<br />**İyi:** Opsiyonel satırlara anlamlı varsayılan değer vermek.<br />**En İyi:** Varsayılan değerleri downstream servisin beklentilerine uygun belirlemek. |

### Güvenlik En İyi Uygulamaları

| Güvenlik Alanı | Açıklama / Uyarılar |
|----------------|---------------------|
| **Hassas Veri İşleme** | Template'lerde hassas veriler (şifre, token) kullanırken dikkatli olun. Hedef değişken adını loglarda görünmeyecek şekilde seçin. |
| **JEXL Expression Güvenliği** | Expression'larda kullanıcı girişinden gelen değerleri doğrudan kullanmaktan kaçının. |
| **Hedef Değişken Kontrolü** | Hedef değişken olarak güvenlik açısından kritik değişkenleri (authentication token vb.) yanlışlıkla overwrite etmeyin. |

### Kaçınılması Gerekenler

| Kategori | Açıklama / Uyarılar |
|----------|---------------------|
| **Boş Satır Listesi** | **Neden kaçınılmalı:** Politika kaydedilse bile hiçbir işlem yapılmaz.<br />**Alternatif:** En az bir satır tanımlayın. |
| **Gereksiz Template Kullanımı** | **Neden kaçınılmalı:** Basit değişken kopyalama için Template modu gereksiz parsing maliyeti oluşturur.<br />**Alternatif:** Basit kopyalamada Form modunu kullanın. |
| **Koşulsuz Zorunlu Satırlar** | **Neden kaçınılmalı:** Her istekte zorunlu kontrol yapılır, bazı endpoint'lerde gereksiz hata fırlatılabilir.<br />**Alternatif:** Zorunlu satırlara uygun koşul ekleyin. |

### Performans İpuçları

| Kriter | Öneri / Etki |
|--------|--------------|
| **Mod Seçimi** | **Öneri:** Mümkün olduğunca Form modunu tercih edin.<br />**Etki:** JEXL parsing maliyetinden kaçınılır. |
| **Satır Sayısı** | **Öneri:** Satır sayısını minimumda tutun, gereksiz atama yapmayın.<br />**Etki:** Her satır ayrı bir işlem döngüsüdür, az satır = düşük gecikme. |
| **Template Karmaşıklığı** | **Öneri:** Template'lerde basit expression'lar kullanın, karmaşık iş mantığını Script politikasına taşıyın.<br />**Etki:** JEXL engine yükü azalır. |
| **Koşul Kullanımı** | **Öneri:** Gereksiz satırları koşul ile filtreleyin.<br />**Etki:** İlgili olmayan isteklerde satır atlanır, throughput artar. |

## Sık Sorulan Sorular (SSS)

| Kategori | Soru | Cevap |
|----------|------|-------|
| **Genel** | Form ve Template modu arasındaki fark nedir? | Form modu tek bir kaynak değişkenden hedefe basit kopyalama yapar. Template modu ise `#{variable}` syntax'ı ve JEXL expression'lar ile birden fazla kaynaktan dinamik içerik üretir. |
| **Genel** | Bu politika gRPC API Proxy'lerinde kullanılabilir mi? | Hayır, Mesaj Oluşturucu politikası yalnızca HTTP API Proxy'lerinde desteklenir. |
| **Teknik** | Template'de hangi değişken türleri kullanılabilir? | Body (JSON path `body.$.path` veya XPath `body.#/path`), Header (`header.Name`), Query (`query.name`), Form (`form.name`), Path (`path.name`) parametreleri ve Context Variable'lar kullanılabilir. |
| **Teknik** | JEXL expression'lar hangi operatörleri destekler? | Aritmetik (`+`, `-`, `*`, `/`), karşılaştırma (`==`, `!=`, `<`, `>`, `<=`, `>=`), mantıksal (`&&`, `\|\|`, `!`) ve ternary (`? :`) operatörleri desteklenir. |
| **Kullanım** | Satır sırası önemli midir? | Evet, satırlar listede göründükleri sırayla çalıştırılır. Bir satırın hedef değişkeni, sonraki satırın kaynağı olabilir. |
| **Kullanım** | Kaynak değer boş olduğunda ne olur? | `Zorunlu=Evet` ise hata fırlatılır. `Zorunlu=Hayır` ise varsayılan değer kullanılır. Varsayılan değer de yoksa boş string atanır. |
| **Teknik** | Template'de `for` döngüsü kullanabilir miyim? | Evet, `#{...}` bloğu içinde çok satırlı JEXL Script yazılabilir. `for (item : body.$.items)` ile JSON array elemanları üzerinde gezinebilirsiniz. JSON array değerleri otomatik olarak listeye dönüştürülür. |
| **Teknik** | JEXL Script'te `return` kullanmalı mıyım? | Hayır, `return` anahtar kelimesi kullanılmaz. Bloğun sonunda son değerlendirilen ifadenin değeri otomatik olarak döndürülür. |
| **Teknik** | Şablon içinde `{}` içeren JSON string üretebilir miyim? | Evet, dengeli parantez tarayıcısı sayesinde `#{...}` bloğu içinde `{` ve `}` serbestçe kullanılabilir. Örneğin: `#{durum == 'aktif' ? '{"etiket":"Aktif"}' : 'null'}` |
| **Teknik** | Body bir JSON dizisiyse eleman nasıl erişirim? | `#{body.$[0].alan}` söz dizimi ile dizinin ilk elemanına erişebilirsiniz. `$[1]`, `$[2]` şeklinde indeks belirterek diğer elemanlara da ulaşılabilir. |
