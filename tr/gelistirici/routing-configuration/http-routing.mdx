---
title: "HTTP Routing Configuration"
description: "Client Route Setup, Upstream Configuration, Load Balancing Options, Path-based, Method-based, Header-based routing"
---

HTTP Routing, API Proxy'nin istemcilerden gelen istekleri nasıl alacağını ve backend API'lere nasıl yönlendireceğini yapılandırmanızı sağlar. Bu sayfa, Client Route yapılandırması, Upstream Target ayarları ve Load Balancing seçeneklerini açıklar.

## Genel Bakış

HTTP Routing yapılandırması iki ana bileşenden oluşur:

<CardGroup cols={2}>
  <Card title="Client Route" icon="arrow-right">
    İstemcilerden gelen isteklerin nasıl alınacağı
  </Card>
  <Card title="Upstream Target" icon="arrow-left">
    İsteklerin backend API'lere nasıl yönlendirileceği
  </Card>
</CardGroup>

## Client Route

Client Route, istemcilerin API Proxy'ye erişmek için kullanacağı yönlendirme bilgisidir. En az bir routing seçeneği (Path, Method veya Header bazlı) seçilmelidir.

### Path-Based Routing

Path-based routing, URL path'ine göre yönlendirme yapar.

#### Relative Paths

API Proxy'ye yönlendirilecek relative URL path'leri. Birden fazla path tanımlanabilir.

**Özellikler:**
* Her path "/" ile başlamalıdır
* Uygulama bazında tekil olmalıdır
* Başka bir path'in başlangıcı olamaz

**Örnekler:**
```
/petstoreProxy
/api/v1/users
/products
/api/v2/orders
```

**Path Matching:**
* **Exact Match**: Tam eşleşme (örn: `/api/users`)
* **Prefix Match**: Önek eşleşmesi (örn: `/api/*`)

#### Path Özellikleri

**Tekil Path:**
```
/api/users
```

**Wildcard Path:**
```
/api/users/*
/api/*/orders
```

**Versioned Path:**
```
/api/v1/users
/api/v2/users
```

### Method-Based Routing

Method-based routing, HTTP metoduna göre yönlendirme yapar.

#### Desteklenen Metodlar

* **GET**: Veri okuma işlemleri
* **POST**: Yeni kayıt oluşturma
* **PUT**: Kayıt güncelleme (tam güncelleme)
* **DELETE**: Kayıt silme
* **PATCH**: Kısmi güncelleme
* **OPTIONS**: CORS preflight istekleri
* **HEAD**: Header bilgilerini alma

#### Method Seçimi

Varsayılan olarak tüm metodlar seçilebilir. Belirli metodlar için routing yapmak istiyorsanız, sadece o metodları seçin.

**Örnek:**
```
GET, POST → Read/Write API
GET → Read-only API
POST, PUT, DELETE → Write API
```

### Header-Based Routing

Header-based routing, HTTP header'larına göre yönlendirme yapar.

#### Header Matching

Header bazlı routing için:

* **Header Name**: Eşleştirilecek header adı
* **Header Value**: Eşleştirilecek header değeri (opsiyonel)
* **Match Type**: Eşleştirme tipi (exact, prefix, regex)

**Örnekler:**
```
X-API-Version: v1
Content-Type: application/json
X-Client-Type: mobile
```

#### Header Routing Senaryoları

**API Version Header:**
```
Header: X-API-Version
Value: v1
→ Routes to v1 backend
```

**Client Type Header:**
```
Header: X-Client-Type
Value: mobile
→ Routes to mobile-optimized backend
```

### Host-Based Routing

Host-based routing, HTTP Host header'ına göre yönlendirme yapar.

#### Host Matching

**Örnekler:**
```
api.example.com → Production API
api-staging.example.com → Staging API
api-dev.example.com → Development API
```

## Upstream Target

Upstream Target, backend API'nin adresi ve yapılandırmasıdır.

### Upstream Target Yapılandırması

#### Backend URL

Backend API'nin base URL'i.

**Format:**
```
http://host:port
https://host:port
```

**Örnekler:**
```
https://api.example.com
http://localhost:8080
https://api.example.com:8443
```

#### Multiple Upstream Targets

Birden fazla upstream target tanımlanabilir. Bu durumda load balancing kullanılır.

**Kullanım Senaryoları:**
* **Load Balancing**: Yük dağılımı
* **Failover**: Yedekleme
* **Blue-Green Deployment**: Mavi-yeşil deployment
* **Canary Deployment**: Canary deployment

### Load Balancing

Birden fazla upstream target varsa, load balancing stratejisi seçilebilir.

#### Load Balancing Stratejileri

**Round Robin:**
* İstekler sırayla dağıtılır
* Her target'a eşit yük dağılımı
* Basit ve etkili

**Least Connections:**
* En az bağlantılı target'a yönlendirme
* Dinamik yük dağılımı
* Yavaş backend'ler için uygun

**IP Hash:**
* İstemci IP'sine göre hash
* Aynı istemci aynı target'a gider
* Session affinity sağlar

**Weighted:**
* Target'lara ağırlık atanır
* Yüksek ağırlıklı target'lara daha fazla istek
* Farklı kapasiteli backend'ler için uygun

#### Load Balancing Örnekleri

**Round Robin:**
```
Target 1: https://api1.example.com (Weight: 1)
Target 2: https://api2.example.com (Weight: 1)
Target 3: https://api3.example.com (Weight: 1)
→ İstekler sırayla dağıtılır
```

**Weighted:**
```
Target 1: https://api1.example.com (Weight: 3)
Target 2: https://api2.example.com (Weight: 2)
Target 3: https://api3.example.com (Weight: 1)
→ Target 1'e 3x, Target 2'ye 2x, Target 3'e 1x istek
```

### Health Check

Upstream target'ların sağlık durumunu kontrol etmek için health check yapılandırması.

#### Health Check Ayarları

* **Enable Health Check**: Health check'i etkinleştir
* **Health Check Path**: Health check endpoint'i (örn: `/health`)
* **Health Check Interval**: Kontrol aralığı (saniye)
* **Health Check Timeout**: Timeout süresi (saniye)
* **Unhealthy Threshold**: Sağlıksız sayılma eşiği
* **Healthy Threshold**: Sağlıklı sayılma eşiği

#### Health Check Örnekleri

**Basit Health Check:**
```
Path: /health
Interval: 10s
Timeout: 5s
```

**Gelişmiş Health Check:**
```
Path: /api/health
Interval: 30s
Timeout: 10s
Unhealthy Threshold: 3
Healthy Threshold: 2
```

### Failover

Bir upstream target başarısız olduğunda, otomatik olarak diğer target'a geçiş.

#### Failover Yapılandırması

* **Enable Failover**: Failover'ı etkinleştir
* **Failover Strategy**: Failover stratejisi
  * **Next Available**: Sıradaki uygun target
  * **Round Robin**: Round robin sırasına göre
  * **Priority Based**: Öncelik sırasına göre

#### Failover Senaryoları

**Primary-Backup:**
```
Primary: https://api1.example.com
Backup: https://api2.example.com
→ Primary başarısız olursa Backup'a geçer
```

**Multiple Backups:**
```
Primary: https://api1.example.com
Backup 1: https://api2.example.com
Backup 2: https://api3.example.com
→ Sırayla yedeklere geçer
```

## Routing Kombinasyonları

Farklı routing seçenekleri birlikte kullanılabilir.

### Path + Method

Path ve method kombinasyonu:

```
Path: /api/users
Method: GET, POST
→ /api/users için GET ve POST istekleri
```

### Path + Header

Path ve header kombinasyonu:

```
Path: /api/*
Header: X-API-Version: v1
→ v1 header'ı olan /api/* istekleri
```

### Method + Header

Method ve header kombinasyonu:

```
Method: POST
Header: Content-Type: application/json
→ JSON POST istekleri
```

## Kullanım Senaryoları

### Senaryo 1: Basit REST API

Basit bir REST API için routing:

**Client Route:**
* Path: `/api/users`
* Methods: GET, POST, PUT, DELETE

**Upstream Target:**
* URL: `https://api.example.com`
* Load Balancing: None (Single target)

### Senaryo 2: Load Balanced API

Yük dengeli API için routing:

**Client Route:**
* Path: `/api/products`
* Methods: GET, POST

**Upstream Targets:**
* Target 1: `https://api1.example.com`
* Target 2: `https://api2.example.com`
* Target 3: `https://api3.example.com`
* Load Balancing: Round Robin
* Health Check: Enabled

### Senaryo 3: Versioned API

Versiyonlu API için routing:

**Client Route:**
* Path: `/api/v1/*`
* Header: `X-API-Version: v1`

**Upstream Target:**
* URL: `https://api-v1.example.com`

**Client Route (v2):**
* Path: `/api/v2/*`
* Header: `X-API-Version: v2`

**Upstream Target:**
* URL: `https://api-v2.example.com`

### Senaryo 4: Multi-Environment Routing

Çoklu ortam routing'i:

**Development:**
* Host: `api-dev.example.com`
* Upstream: `http://localhost:8080`

**Staging:**
* Host: `api-staging.example.com`
* Upstream: `https://api-staging.example.com`

**Production:**
* Host: `api.example.com`
* Upstream: `https://api.example.com` (Load balanced)

## En İyi Uygulamalar

### Path Tasarımı

* **RESTful Convention**: RESTful konvansiyonlarına uyun
* **Versioning**: Versiyonlama için path kullanın (`/api/v1/`, `/api/v2/`)
* **Tekil Path'ler**: Path'lerin uygulama bazında tekil olduğundan emin olun
* **Açıklayıcı Path'ler**: Path'leri açıklayıcı ve anlaşılır tutun

### Load Balancing

* **Health Check**: Health check'i her zaman aktif tutun
* **Strateji Seçimi**: İhtiyaca göre uygun stratejiyi seçin
* **Weighted Balancing**: Farklı kapasiteli backend'ler için weighted kullanın
* **Failover**: Failover'ı yapılandırın

### Upstream Target

* **HTTPS**: Production'da HTTPS kullanın
* **Connection Pooling**: Bağlantı havuzunu optimize edin
* **Timeout**: Timeout değerlerini uygun ayarlayın
* **Monitoring**: Upstream target'ları izleyin

## Sonraki Adımlar

<CardGroup cols={2}>
  <Card title="gRPC Routing" icon="network-wired" href="/tr/gelistirici/gRPC-routing">
    gRPC routing yapılandırması
  </Card>
  <Card title="WebSocket Routing" icon="globe" href="/tr/gelistirici/websocket-routing">
    WebSocket routing yapılandırması
  </Card>
  <Card title="API Proxy Configuration" icon="gear" href="/tr/gelistirici/api-proxy-konfigurasyonu/overview">
    API Proxy konfigürasyonu
  </Card>
  <Card title="Load Balancing" icon="balance-scale" href="/tr/gelistirici/http-routing#load-balancing">
    Load balancing detayları
  </Card>
</CardGroup>
