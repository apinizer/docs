---
title: "OIDC Entegrasyonu"
description: "Groovy script politikası ile OIDC (OpenID Connect) entegrasyonu"
---

Bu sayfa, Groovy script politikası kullanarak OIDC (OpenID Connect) entegrasyonunun nasıl yapılacağını açıklar.

## API Proxy İstek Hattı Scripti

API Proxy istek hattına eklenecek olan groovy scripti:

```groovy
//v18
import groovy.json.JsonSlurper
import groovy.json.JsonOutput
import java.net.URLEncoder
import java.net.URLDecoder
import java.util.zip.GZIPOutputStream
import java.util.zip.GZIPInputStream
import java.io.ByteArrayOutputStream
import java.io.ByteArrayInputStream
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.security.SecureRandom
import java.time.Instant
import java.util.Base64
import java.util.UUID
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import org.apache.http.client.methods.HttpGet
import org.apache.http.client.methods.HttpPost
import org.apache.http.impl.client.HttpClients
import org.apache.http.entity.StringEntity
import org.apache.http.util.EntityUtils

// ################## OIDC Configuration ##################
def OIDC_CONFIG = [
    clientId: "client_name",
    clientSecret: "client_secret",
    realm: "realm_name",
    scope: "openid email",
    discovery: "https://auth.keycloak.local/realms/realm_name/.well-known/openid-configuration",
    authorizationEndpoint: "https://auth.keycloak.local/realms/realm_name/protocol/openid-connect/auth",
    introspectionEndpoint: "https://auth.keycloak.local/realms/realm_name/protocol/openid-connect/token/introspect",
    tokenEndpoint: "https://auth.keycloak.local/realms/realm_name/protocol/openid-connect/token",
    redirectAfterLogoutUri: "https://auth.keycloak.local/realms/realm_name/protocol/openid-connect/logout",
    postLogoutRedirectUri: "https://application.local/application_ui/",
    logoutPath: "/logout",
    redirectUri: "https://application.local/application_ui/",
    redirectAfterLogoutWithIdTokenHint: true,
    usePkce: true,
    useNonce: true,
    bearerJwtAuthEnable: true,
    accessTokenHeaderName: "Authorization",
    accessTokenAsBearer: true,
    addAccessTokenHeader: true,
    authAcceptTokenAs: "header_cookie",
    addTokenToCookie: true,
    addIdTokenHeader: false,
    idTokenHeaderName: "IdToken",
    disableUserinfoHeader: false,
    userinfoHeaderName: "UserInfo",
    ignoreRequestMethods: ["OPTIONS"],
    ignoreRequestPatterns: "static/media,static/js,static/css,static/html,*.json,*.ico,*.png,*.svg,*.js,*.woff2,*.css,*.html,bnpl-result,bnpl-workflow-fail",
    accessTokenCookieName: "authorization",
    enableRefreshTokenCookie: false,
    refreshTokenCookieName: "refresh-token-cookie",
    enableIdTokenCookie: false,
    idTokenCookieName: "id-token-cookie",
    validateAccessTokenWithApi: true,
    validateIssuer: true,
    expectedIssuer: "https://auth.keycloak.local/realms/realm_name",
    validateAudience: false,
    expectedAudience: "client name",
    sessionCookieName: "cookie name",
    sessionCookieSecure: true,
    sessionAbsoluteTimeout: 34560000,
    encryptionKey: "c2d6b2n4f6k6l7n8m9f0s1b5b4v3x1z2",
    encryptionIv: "z9x8c7v6b5n4g7h8",
    debugEnabled: true,
    setCookieDelimiter: "#"
]

// ... (script devam ediyor - tam içerik için kaynak sayfaya bakınız)
```

## API Proxy Hata Hattı Scripti

API Proxy hata hattına eklenecek olan groovy scripti:

```groovy
if(customVariableMap.get("Location")!=null ){
    responseHeaderMapToClient.put("Location", customVariableMap.get("Location"))
    statusCodeToClient=302;
}

customVariableMap.each { key, value ->
    if (key.toLowerCase().contains("cookie")) { 
        responseHeaderMapToClient.put(key, value)
    }
}
```

## Önemli Notlar

### Sorun 1: OIDC Parametrelerinin İletim Modu

**Sorun:** Varsayılan olarak, OIDC kimlik doğrulama işlemi parametreleri URL fragment'ları (#) kullanarak döndürür. Ancak fragment değerleri tarayıcıda kalır ve sunucuya gönderilmez. Bu durum, araya gateway çözümü eklendiğinde kimlik doğrulama hatalarına neden olur.

**Çözüm:** OIDC yapılandırmanızda `response_mode` parametresini `"query"` olarak ayarlamanız gerekmektedir. Bu sayede parametreler fragment yerine query parametreleri (?) ile iletilir ve sunucuya başarıyla aktarılır.

**Yapılandırma:**
- Keycloak için: İstemci ayarlarında, "Advanced Settings" (Gelişmiş Ayarlar) altında, "Response Mode" değerini "query" olarak ayarlayın.
- Diğer OIDC sağlayıcıları için: İlgili istemci yapılandırmasında `response_mode=query` parametresini ekleyin.

### Sorun 2: Nginx Ingress Controller ile Header Boyutu Sınırlamaları

**Sorun:** OIDC'yi Nginx Ingress Controller ile kullanırken, kimlik doğrulama çerezleri ve başlıkları varsayılan tampon boyutu sınırlarını aşabilir. Bu durum, kimlik doğrulama işlemi sırasında 400 Bad Request hatalarına veya kesik başlıklara neden olur.

**Çözüm:** Nginx Ingress Controller yapılandırmanızda tampon boyutu ayarlarını artırın:

```
nginx.ingress.kubernetes.io/proxy-buffer-size: "8k"
nginx.ingress.kubernetes.io/client-header-buffer-size: "8k"
nginx.ingress.kubernetes.io/large-client-header-buffers: "4 8k"
```

Bu ayarlar, Nginx Ingress Controller'ın OIDC kimlik doğrulama token'ları ve çerezleriyle yaygın olarak karşılaşılan daha büyük başlıkları düzgün bir şekilde işlemesini sağlar.

<Warning>
Bu script çok kapsamlı bir OIDC entegrasyonu içermektedir. Tam script içeriği için kaynak sayfaya bakınız: https://docs.apinizer.com/apinizer-dokumantasyonu/oidc-entegrasyonu-126910690.html
</Warning>
