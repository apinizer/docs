---
title: REST API'ye Database Provider Aracılığıyla Plain-Text Authentication Politikasının Uygulanması
---

# REST API'ye Database Provider Aracılığıyla Plain-Text Authentication Politikasının Uygulanması

Bu senaryoda **Swagger Petstore** isimli **REST** mimaride oluşturulmuş bir **API'ye**, **Plain-Text Authentication** politikasının uygulanması test edilecektir.

Aşağıdaki grafikte yer alan numaralandırmalar işlemlerin **yapılış sırasına aittir.**

- **Apinizer** içerisinde yer alan **Security Manager, API Client'tan Plain-Text türünde** güvenlik bilgisinin gelmesini bekler.
- **Authentication** bilgileri kontrol edilmek üzere veritabanına gönderilir.
- **Veritabanından** Apinizer'a authentication bilgileriyle ilgili cevap döner. Bu authentication doğrulaması yapılamazsa Apinizer isteği keser ve 6 numaralı adım'a atlanılarak hata mesajı döner. Doğrulama yapılabilirse akış devam eder.
- **Apinizer, Backend API'ye istekte** bulunur.
- **Backend API, Apinizer'a** yanıt verir.
- **Apinizer, API Client'a** yanıtı iletir.

## API Proxy'nin Oluşturulması

Swagger Petstore isimli REST API'ye [https://petstore.swagger.io/](https://petstore.swagger.io/) adresinden erişim sağlanabilmektedir.

İlk olarak bu adresin **API Proxy** olarak tanımlanması gereklidir.

Bunun için **Development** menüsü altında yer alan **API Proxies** seçeneğine tıklanır.

Açılan sayfada daha önceden herhangi bir **proxy** tanımı yapılmadığı için **No records found!** yazısı yer alabilir.

Burada sağ üst köşede yer almakta olan **Create** butonuna tıklanır ve yeni bir **proxy** oluşturmaya başlanır.

Bu kısımda oluşturulacak olan **API Proxy'nin** hangi tipte olduğunun seçilmesi gerekmektedir.

Bu senaryoda kullanılacak olan API'nin türü **Swagger 2.X** olacağı için bu tür seçilir.

**Enter URL** ifadesine tıklanarak kullanılacak olan API'nin adresinin girileceği ekrana geçiş yapılır.

Aşağıdaki görselde de görüldüğü üzere URL kısmına **erişim sağlanacak dokümantason adresi** girilerek **Parse** butonuna tıklanır.

Parse işlemi yapıldıktan sonra ise aşağıdaki görselde yer alan ekran gelmektedir. Bu ekran üzerinden API Proxy'ye ait ayarlar yapılabilmektedir.

- **Usage** alanı ile oluşturulan API Proxy'nin kim tarafından kullanılacağı belirtilir. Burada **publisher, consumer, publisher and consumer** gibi seçenekler yer almaktadır.
- **Sharing Type** alanı ile oluşturulan API Proxy'nin paylaşım tipi belirtilir. Burada **external, internal, external and internal** gibi seçenekler yer almaktadır.
- **Addresses** sekmesi altında yer alan iki API adresinden biri veya her ikisi de seçilebilir eğer iki adres de seçilecek olursa Apinizer **Load Balance** işlemini kendisi gerçekleştirecektir.
- **Relative Path** ise oluşturulan API Proxy'nin erişime açılacak adresidir.
- **Category List** alanı da oluşturulan API Proxy'nin kategorilendirilmesine olanak sağlar.
- Bu ayarlamalar yapıldıktan sonra API Proxy kaydedilir.

Kaydetme işleminden sonra ise açılan sayfada **Develop** sekmesine tıklanır.

Burada **REST API'ye** ait **metotlar (endpoint'ler)** listelenmektedir.

- Bu endpointlerin üstünde yer almakta olan **All** ifadesiyle eklenecek politikalar **tüm metotlara** uygulanabilmektedir.
- Oluşturulan API proxy deploy edilir. Bunun için yukarıda orta kısımda yer alan **Deploy** butonuna tıklanır.
- Sırada bu işlemde senaryo gereği kullanılması gereken veritabanı bağlantısı tanımının yapılması vardır.
- Politika olarak eklenecek **Plain-Text Authentication** yapısı içerisinde kontrol edilecek olan **username** ve **password** ikilisinden bir bir örnek bilinirse işlemler sonunda akış test edilebilir.
- İlk olarak veritabanı bağlantısı sonrasında Veritabanı ile Kimlik Doğrulama ayarları yapılır.

## Veritabanı Bağlantısının Gerçekleştirilmesi

- **Connection Management** menüsü altında yer alan **Veritabanı** menüsüne tıklanır.
- Daha önceden herhangi bir veritabanı tanımı gerçekleştirilmemiş ise bu sayfada **No records found!** yazısı görülebilir.
- Veritabanı bağlantısını oluşturmak için sağ üst köşede yer alan **Create** butonuna tıklanır.

Bu ekran üzerinde yer alan ifadeler tek tek incelenecek olursa,

- **Name** alanı ile oluşturulan bağlantının ismi ifade edilir.
- **Description** ifadesi ile oluşturulan bağlantıya açıklama eklenebilir.
- **JDBC URL** alanı ile bağlanılacak olan veritabanına bağlanmak için gerekli olan JDBC adresi yazılır. Bu bilgi veritabanı ekibinden edinilebilir.
- **Username** alanı ile bağlantı esnasında kullanılacak olan kullanıcı adı bilgisi, **Password** alanı ile de bağlantı esnasında kullanılacak olan parola girilir.
- Veritabanı yöneticisi veya ekibinden sağ taraftaki bağlantı bilgileri ile ilgili en uygun değerler ne olacak bilgisi alınarak bu kısım düzenlenir.

Yukarıda belirtilen alanlar senaryoda kullanılacağı şekilde doldurulur.

**Test Connection** butonuna tıklanarak test işlemi gerçekleştirilir, **Save and Deploy** butonuna tıklanarak da işlemler kaydedilir.

Kayıt işlemi gerçekleştikten sonra ise aşağıdaki görselde yer aldığı gibi oluşturulan bağlantı görüntülenir.

## Veritabanı ile Kimlik Doğrulama Bağlantılarının eklenmesi

Aşağıda görüldüğü üzere Identitiy Management > Identity Providers > Database bölümünden daha önce oluşturulmuş veritabanı ile kimlik doğrulama tanımını eklemek üzere giriş yapılır.

### Veritabanı ile Kimlik Doğrulama (Authentication) Bağlantısı

İlgili sayfaya giriş yaptıktan sonra Create tuşuna basılır ve bağlantı ayarları aşağıda gösterilen görseldeki gibi girilir.

- Bağlantıya isim ve açıklama girilir.
- **Encryption Type** ile veritabanı bağlantısında kullanılacak tabloda **parola** bilgisi şifreli tutuluyor ise tabloda tutulan şifreye ait şifreleme türü seçilmelidir.
- **Database Connection Pool Definition** alanı ile önceki adımlarda hazırlanan veritabanı seçilir.
- Bir sorgu veritabanından Kullanıcı adı/parola çiftlerini ya da rol listesini almak için kullanılır. Sorguda kullanıcı adı parametresi ":username" şeklinde ve parola parametresi ":password" şeklinde tanımlanmalıdır. Apinizer iki nokta üsüste karakterini algılar ve ilgili parametrenin dışarıdan gönderileceğini bilerek buna göre işlem yapar.
- **Test Username** ve **Test Password** alanları **veritabanında** olan bir bilgi doldurularak sorgunun çalışıp çalışmadığı test edilebilir. **Yapılan tanımı kaydetmeden önce bu alanların temizlenmesi tavsiye edilmektedir.**

### Veritabanı ile Kimlik Yetkilendirmesi (Authorization) Bağlantısı

Kimlik doğrulama bağlantısından tek farkı girilen query'dir bu alanda kimlik yetkilendirme işlemi yapılacağı için query kısmında sadece ilgili rolün adı alınır.

## Authentication Politikasının Oluşturulması

API proxy'lerin listelendiği sayfaya gidilir ve buradan **Swagger Petstore** isimli proxy seçilir.

Daha sonra ise **Develop** sekmesine gelinir, **Add Policy** butonuna tıklanır.

Açılan sayfada **Plain-Text Authentication** politikası seçilir.

Aşağıdaki ekran üzerinde yer alan ifadeler tek tek incelenecek olursa,

- **Identity/Role/Group Service** alanında **veritabanı** bölümünden kontrolü sağlayacak veritabanı seçilir.
- **Variable for username** ve **variable for password** ifadeleri ile de kullanıcı adı ve parola bilgisinin hangi değişken ile alınacağı seçilir. Bu senaryoda bu değerler **header** içerisinden username ve password değerlerinde beklenecek ve alınacaktır.
- **Clear Authentication Information** seçeneği seçilirse gelen mesaj içerisinde authentication bilgisi, backend api'ye giderken temizlenir. **Bu ayarın aktifleştirilmesi özel bir durum olmadığı sürece her zaman tavsiye edilmektedir.**
- **Add Client Info To Header** seçeneği backend API'ye gidecek Header içerisinde ayrı bir header değeri ile kullanıcı adının iletilmesini sağlar.
- **Authorization Configuration** alanında kullanıcı kimlik doğrulaması gerçekleştirilmiş kişilerin rolleriyle ilgili kurallar girilebilecek alandır.
- **Add Roles To Header** seçeneği seçilirse yetkilendirme başarılı olduğu takdirde istemcinin rollerini "X-Authenticated-UserRoles" başlığına ekler.
- **Identity/Role/Group Service** alanında seçilecek **veritabanı** bölümünden rol bilgilerinin bulunduğu veritabanı seçilir. Bu genelde kimlik kontrolünü sağlayan veritabanı ile aynı tanımla yapılmaktadır.
- **Roles/Group** alanında kimlik yetkilendirilmesi yapılacak roller girilir.
- İstemcinin, API'ye erişmek için burada tanımlanan rollerin/grupların **tümüne** mi **herhangi birine** mi sahip olması yeterli olacaktır ayarı yapılır.
- **Enable Role/Group Based Method Access** seçeneği seçildiği zaman önce API'ye erişim izni verilen roller kontrol edilir. Ardından, metodlara erişimi kontrol etmek için diğer rollere bakılır.

Politika kaydolduğu zaman kırmızı dikdörtgen içerisine alınmış ikon görülmektedir.

Yapılan işlemin geçerli olması için proxy'nin **Redeploy** edilmesi gerekmektedir. Redeploy işlemi sonrası API proxy test edilebilir.

## API Proxy'nin Test Edilmesi

**"/pet/{petId}"** gibi bir endpoint seçildikten sonra, **Test Endpoint** butonuna tıklanır.

URL'de ya da parametre sekmesinde istenilen pet id değeri girilir, **Send** butonuna basıldığında dönen yanıt bir hata mesajı olacaktır ve bu hatanın da uygulanmış olan **Plain-Text Authentication** ile alakalı olduğu görülecektir.

Çünkü henüz **header'lar** içerisine hiçbir şekilde bir **authentication** bilgisi yerleştirilmemiştir.

**Backend API'ye** gönderilecek olan header'lar içerisinde username ve password header'larında veritabanında olan bir kullanıcının bilgileri girilerek test tekrarlanır ve başarılı cevap alınması beklenir.
